<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CatraLibraries: PosixThread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CatraLibraries
   </div>
   <div id="projectbrief">CatraLibrariesisageneral-purposeC++framework.Itisplatformindependent(Unix,MAC,Windows,...)andprovidesclassestomanagePOSIXthreads,Sockets,SocketsConnectionManager,Tracer,Scheduler,EventsSet,Configurationfiles,HTTPCacheManager,SoftwareLoadBalancer,FTP,Tools(Buffers/Strings,DateTime,FileIO,FileReader,CPUUsage,Networks,Processes,Services,...),WebTools(HTTPGET,HTTPPOST,HTTPServer,...),Databaseaccess(Oracle,Sybase),,...</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPosixThread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PosixThread Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="PosixThread_8h_source.html">PosixThread.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PosixThread:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPosixThread.png" usemap="#PosixThread_map" alt=""/>
  <map id="PosixThread_map" name="PosixThread_map">
<area href="classBaseProcessor.html" alt="BaseProcessor" shape="rect" coords="141,56,272,80"/>
<area href="classHTTPCacheManager.html" alt="HTTPCacheManager" shape="rect" coords="141,112,272,136"/>
<area href="classHttpGetThread.html" alt="HttpGetThread" shape="rect" coords="141,168,272,192"/>
<area href="classHttpPostThread.html" alt="HttpPostThread" shape="rect" coords="141,224,272,248"/>
<area href="classHttpServer.html" alt="HttpServer" shape="rect" coords="141,280,272,304"/>
<area href="classLoadBalancer.html" alt="LoadBalancer" shape="rect" coords="141,336,272,360"/>
<area href="classScheduler.html" alt="Scheduler" shape="rect" coords="141,392,272,416"/>
<area href="classSocketsPool.html" alt="SocketsPool" shape="rect" coords="141,448,272,472"/>
<area href="classTracer.html" alt="Tracer" shape="rect" coords="141,504,272,528"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acdcfbeef3e341707157ee814ffd41496"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdcfbeef3e341707157ee814ffd41496"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PThreadStatus</b> { <br />
&#160;&#160;<b>THREADLIB_BUILDED</b>, 
<b>THREADLIB_INITIALIZED</b>, 
<b>THREADLIB_STARTED</b>, 
<b>THREADLIB_DETACHED</b>, 
<br />
&#160;&#160;<b>THREADLIB_STARTED_AND_JOINED</b>, 
<b>THREADLIB_INITIALIZEDAGAINAFTERRUNNING</b>
<br />
 }</td></tr>
<tr class="separator:acdcfbeef3e341707157ee814ffd41496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a8d25c8f722e50f82b65e1da741a0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41a8d25c8f722e50f82b65e1da741a0c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PThreadInheritScheduling</b> { <b>THREADLIB_INHERITSCHED</b> = PTHREAD_INHERIT_SCHED, 
<b>THREADLIB_DEFAULTSCHED</b> = PTHREAD_EXPLICIT_SCHED
 }</td></tr>
<tr class="separator:a41a8d25c8f722e50f82b65e1da741a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63734ad911205f52c0be866cb95b3c5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63734ad911205f52c0be866cb95b3c5c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PThreadSchedulingPolicy</b> { <b>THREADLIB_SCHEDFIFO</b> = SCHED_FIFO, 
<b>THREADLIB_SCHEDRR</b> = SCHED_RR, 
<b>THREADLIB_SCHEDOTHER</b> = SCHED_OTHER
 }</td></tr>
<tr class="separator:a63734ad911205f52c0be866cb95b3c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f8bd904274e91b63097335e4f07a86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74f8bd904274e91b63097335e4f07a86"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PThreadPriority</b> { <b>THREADLIB_PRIORITY_MIN</b> = -1000, 
<b>THREADLIB_PRIORITY_MEDIUM</b> = -2000, 
<b>THREADLIB_PRIORITY_MAX</b> = -3000
 }</td></tr>
<tr class="separator:a74f8bd904274e91b63097335e4f07a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabb2fba8e227d012076f44471673826"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adabb2fba8e227d012076f44471673826"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PThreadCancellationState</b> { <b>THREADLIB_CANCEL_OFF</b> = PTHREAD_CANCEL_DISABLE, 
<b>THREADLIB_CANCEL_ON</b> = PTHREAD_CANCEL_ENABLE
 }</td></tr>
<tr class="separator:adabb2fba8e227d012076f44471673826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ecea589dbcaeb227a85fdb79ef210f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10ecea589dbcaeb227a85fdb79ef210f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PThreadCancellationType</b> { <b>THREADLIB_CANCEL_ASYNCHRONOUS</b>, 
<b>THREADLIB_CANCEL_DEFERRED</b> = PTHREAD_CANCEL_DEFERRED
 }</td></tr>
<tr class="separator:a10ecea589dbcaeb227a85fdb79ef210f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c9420691742d21a4edbdde8148fac4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7c9420691742d21a4edbdde8148fac4"></a>
typedef enum <br class="typebreak" />
PosixThread::PThreadStatus&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadStatus_t</b></td></tr>
<tr class="separator:ab7c9420691742d21a4edbdde8148fac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3889a672d1e6c95fa7f6305bbbd1b036"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3889a672d1e6c95fa7f6305bbbd1b036"></a>
typedef enum <br class="typebreak" />
PosixThread::PThreadStatus *&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadStatus_p</b></td></tr>
<tr class="separator:a3889a672d1e6c95fa7f6305bbbd1b036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a82db152992fdca9e8ca81d92d7c3d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a82db152992fdca9e8ca81d92d7c3d8"></a>
typedef enum <br class="typebreak" />
PosixThread::PThreadInheritScheduling&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadInheritScheduling_t</b></td></tr>
<tr class="separator:a9a82db152992fdca9e8ca81d92d7c3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b9eeda2684e516be1845791b82dcdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95b9eeda2684e516be1845791b82dcdc"></a>
typedef enum <br class="typebreak" />
PosixThread::PThreadInheritScheduling *&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadInheritScheduling_p</b></td></tr>
<tr class="separator:a95b9eeda2684e516be1845791b82dcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828754d4b13e7b1aa021d60073a8a589"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a828754d4b13e7b1aa021d60073a8a589"></a>
typedef enum <br class="typebreak" />
PosixThread::PThreadSchedulingPolicy&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadSchedulingPolicy_t</b></td></tr>
<tr class="separator:a828754d4b13e7b1aa021d60073a8a589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36238d8b97054282019e4bfaeaef3397"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36238d8b97054282019e4bfaeaef3397"></a>
typedef enum <br class="typebreak" />
PosixThread::PThreadSchedulingPolicy *&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadSchedulingPolicy_p</b></td></tr>
<tr class="separator:a36238d8b97054282019e4bfaeaef3397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433804319b1899e4aa9d411011624c8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a433804319b1899e4aa9d411011624c8d"></a>
typedef enum <br class="typebreak" />
PosixThread::PThreadPriority&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadPriority_t</b></td></tr>
<tr class="separator:a433804319b1899e4aa9d411011624c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7c8ca58b5953b82058a70ea71f1dd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f7c8ca58b5953b82058a70ea71f1dd7"></a>
typedef enum <br class="typebreak" />
PosixThread::PThreadPriority *&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadPriority_p</b></td></tr>
<tr class="separator:a5f7c8ca58b5953b82058a70ea71f1dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94d6b78f0d098d3f81dea866db0899f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af94d6b78f0d098d3f81dea866db0899f"></a>
typedef enum <br class="typebreak" />
PosixThread::PThreadCancellationState&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadCancellationState_t</b></td></tr>
<tr class="separator:af94d6b78f0d098d3f81dea866db0899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab0249e4d04a4395e603046d221c97c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afab0249e4d04a4395e603046d221c97c"></a>
typedef enum <br class="typebreak" />
PosixThread::PThreadCancellationState *&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadCancellationState_p</b></td></tr>
<tr class="separator:afab0249e4d04a4395e603046d221c97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa080fef1dc4e406611aa05bf1680bad3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa080fef1dc4e406611aa05bf1680bad3"></a>
typedef enum <br class="typebreak" />
PosixThread::PThreadCancellationType&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadCancellationType_t</b></td></tr>
<tr class="separator:aa080fef1dc4e406611aa05bf1680bad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24225c7f13616e1719f57af352b3721e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24225c7f13616e1719f57af352b3721e"></a>
typedef enum <br class="typebreak" />
PosixThread::PThreadCancellationType *&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadCancellationType_p</b></td></tr>
<tr class="separator:a24225c7f13616e1719f57af352b3721e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2901391170273e771247e28007b47951"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a2901391170273e771247e28007b47951">PosixThread</a> ()</td></tr>
<tr class="separator:a2901391170273e771247e28007b47951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6630099d144f1362862f4421a9589d6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#af6630099d144f1362862f4421a9589d6">~PosixThread</a> ()</td></tr>
<tr class="separator:af6630099d144f1362862f4421a9589d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50c2697c5965c9d0c8d50a68cb7e1c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af50c2697c5965c9d0c8d50a68cb7e1c6"></a>
<a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (const char *pPThreadName=&quot;&quot;)</td></tr>
<tr class="separator:af50c2697c5965c9d0c8d50a68cb7e1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbbfd62e79a3e6521597340e4fc788f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbbbfd62e79a3e6521597340e4fc788f"></a>
virtual <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>finish</b> (void)</td></tr>
<tr class="separator:afbbbfd62e79a3e6521597340e4fc788f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af404afc021adec86bebb80488b00cc4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af404afc021adec86bebb80488b00cc4b"></a>
<a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getThreadState</b> (PThreadStatus_p pstThreadState)</td></tr>
<tr class="separator:af404afc021adec86bebb80488b00cc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486c6584ac710298bf5cb45a85af980a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a486c6584ac710298bf5cb45a85af980a"></a>
PThreadStatus_t&#160;</td><td class="memItemRight" valign="bottom"><b>getThreadState</b> (void)</td></tr>
<tr class="separator:a486c6584ac710298bf5cb45a85af980a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7ea1cfe3d623f149bdb391167a0ebe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#ace7ea1cfe3d623f149bdb391167a0ebe">setPriority</a> (long lNewPriority)</td></tr>
<tr class="separator:ace7ea1cfe3d623f149bdb391167a0ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4dcb96d7434b084436e601ba96d541"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a8e4dcb96d7434b084436e601ba96d541">getPriority</a> (long *plPriority)</td></tr>
<tr class="separator:a8e4dcb96d7434b084436e601ba96d541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab123363102c69a65ee3366bb99381149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#ab123363102c69a65ee3366bb99381149">setInheritScheduling</a> (PThreadInheritScheduling_t isNewInheritScheduling)</td></tr>
<tr class="separator:ab123363102c69a65ee3366bb99381149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab043a6789909d7463b3a61dd57e33108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#ab043a6789909d7463b3a61dd57e33108">getInheritScheduling</a> (PThreadInheritScheduling_p pisInheritScheduling)</td></tr>
<tr class="separator:ab043a6789909d7463b3a61dd57e33108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f2a4c995f0bdfac240f8973cebf4d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a21f2a4c995f0bdfac240f8973cebf4d0">setSchedulingPolicy</a> (PThreadSchedulingPolicy_t spNewSchedulingPolicy)</td></tr>
<tr class="separator:a21f2a4c995f0bdfac240f8973cebf4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5a9e6da7c2aad005fcf9564536de8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a3f5a9e6da7c2aad005fcf9564536de8c">getSchedulingPolicy</a> (PThreadSchedulingPolicy_p pspSchedulingPolicy)</td></tr>
<tr class="separator:a3f5a9e6da7c2aad005fcf9564536de8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fdfadeb522f9c7b1a9a5e02f4f8e07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a74fdfadeb522f9c7b1a9a5e02f4f8e07">setStackSize</a> (long lNewStackSize)</td></tr>
<tr class="separator:a74fdfadeb522f9c7b1a9a5e02f4f8e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eeaa1b26df7f79b824cb1e3d9c7da2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a25eeaa1b26df7f79b824cb1e3d9c7da2">getStackSize</a> (long *plStackSize)</td></tr>
<tr class="separator:a25eeaa1b26df7f79b824cb1e3d9c7da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaca64786c9643d606b794133388d3b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#affaca64786c9643d606b794133388d3b">start</a> (Boolean_t bToBeDetached=false)</td></tr>
<tr class="separator:affaca64786c9643d606b794133388d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fdda808044bfcfd81b9f8a4f9a713a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a82fdda808044bfcfd81b9f8a4f9a713a">getThreadIdentifier</a> (unsigned long *pulThreadIdentifier) const </td></tr>
<tr class="separator:a82fdda808044bfcfd81b9f8a4f9a713a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61712f976f5254a45c55eea8cd342f51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a61712f976f5254a45c55eea8cd342f51">operator long</a> (void) const </td></tr>
<tr class="separator:a61712f976f5254a45c55eea8cd342f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b183f79c1ac18cfb8d4368601f8c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a70b183f79c1ac18cfb8d4368601f8c13">setCurrentPriority</a> (long lNewCurrentPriority)</td></tr>
<tr class="separator:a70b183f79c1ac18cfb8d4368601f8c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d79e057da03d98b2f50d0505abaa57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a91d79e057da03d98b2f50d0505abaa57">getCurrentPriority</a> (long *plCurrentPriority)</td></tr>
<tr class="separator:a91d79e057da03d98b2f50d0505abaa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e67d24081f87c257f6b7ffe1ad8e75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a22e67d24081f87c257f6b7ffe1ad8e75">getPThreadName</a> (char *pPThreadName)</td></tr>
<tr class="separator:a22e67d24081f87c257f6b7ffe1ad8e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ecdacea37722cb68ecf5e8fc71edd1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a47ecdacea37722cb68ecf5e8fc71edd1">cancel</a> (void)</td></tr>
<tr class="separator:a47ecdacea37722cb68ecf5e8fc71edd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b2e7c68414996d2aeb79ff4c039ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a28b2e7c68414996d2aeb79ff4c039ba0">setCancelType</a> (PThreadCancellationType_t ctCancelType)</td></tr>
<tr class="separator:a28b2e7c68414996d2aeb79ff4c039ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788c5ceb2bfc97967770cb5dfa37a667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a788c5ceb2bfc97967770cb5dfa37a667">getThreadError</a> (<a class="el" href="classError.html">Error</a> *perrThreadError)</td></tr>
<tr class="separator:a788c5ceb2bfc97967770cb5dfa37a667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa075c024237249d38f97e55e9cbd0ae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#aa075c024237249d38f97e55e9cbd0ae8">join</a> (Error_p perrJoinError)</td></tr>
<tr class="separator:aa075c024237249d38f97e55e9cbd0ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2efa899a1f3a094ca7f3491c3dd8a8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#ac2efa899a1f3a094ca7f3491c3dd8a8b">detach</a> (void)</td></tr>
<tr class="separator:ac2efa899a1f3a094ca7f3491c3dd8a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3d6f0d691d187706026c89315b1bb930"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d6f0d691d187706026c89315b1bb930"></a>
static <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getThreadIdentifier</b> (const pthread_t *pThread, unsigned long *pulThreadIdentifier)</td></tr>
<tr class="separator:a3d6f0d691d187706026c89315b1bb930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf2b05ffb4a1a4b081842c3b7851e7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaf2b05ffb4a1a4b081842c3b7851e7f"></a>
static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentThreadIdentifier</b> (void)</td></tr>
<tr class="separator:abaf2b05ffb4a1a4b081842c3b7851e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a25d4027bfc99d96f359a4ef6fb02c8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a6a25d4027bfc99d96f359a4ef6fb02c8">getCurrentThread</a> (pthread_t &amp;pThread)</td></tr>
<tr class="separator:a6a25d4027bfc99d96f359a4ef6fb02c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51daa00bef6a221fb1a4257ccbe95dd8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a51daa00bef6a221fb1a4257ccbe95dd8">yield</a> (void)</td></tr>
<tr class="separator:a51daa00bef6a221fb1a4257ccbe95dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96135298bdeeb774752abce6cdf47e34"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a96135298bdeeb774752abce6cdf47e34">getSleep</a> (unsigned long ulSeconds, unsigned long ulAdditionalMicroSeconds)</td></tr>
<tr class="separator:a96135298bdeeb774752abce6cdf47e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5518cb0a6ca7fa8401f8129195f17b57"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a5518cb0a6ca7fa8401f8129195f17b57">exit</a> (void)</td></tr>
<tr class="separator:a5518cb0a6ca7fa8401f8129195f17b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0438bf0771b6f07c082077bf3574c5dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a0438bf0771b6f07c082077bf3574c5dc">testCancel</a> (void)</td></tr>
<tr class="separator:a0438bf0771b6f07c082077bf3574c5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d1bd9a6abb5a67812a5bbb755f2b45"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a48d1bd9a6abb5a67812a5bbb755f2b45">setCancel</a> (PThreadCancellationState_t csCancelability)</td></tr>
<tr class="separator:a48d1bd9a6abb5a67812a5bbb755f2b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a12972b5b5f07af252cfe22e905ead79e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12972b5b5f07af252cfe22e905ead79e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PosixThread</b> (const <a class="el" href="classPosixThread.html">PosixThread</a> &amp;t)</td></tr>
<tr class="separator:a12972b5b5f07af252cfe22e905ead79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c91cc07ed780984f6de7877240c548"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97c91cc07ed780984f6de7877240c548"></a>
virtual <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>run</b> (void)=0</td></tr>
<tr class="separator:a97c91cc07ed780984f6de7877240c548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4611d1834f592b27d96729ebfdd8bfcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPosixThread.html#a4611d1834f592b27d96729ebfdd8bfcf">setPThreadName</a> (const char *pPThreadName)</td></tr>
<tr class="separator:a4611d1834f592b27d96729ebfdd8bfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a94162d6d7d9cf7d22f44e44d6a3289ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94162d6d7d9cf7d22f44e44d6a3289ff"></a>
pthread_t&#160;</td><td class="memItemRight" valign="bottom"><b>_pThread</b></td></tr>
<tr class="separator:a94162d6d7d9cf7d22f44e44d6a3289ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c08138675171bf4754628edc97ac63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98c08138675171bf4754628edc97ac63"></a>
pthread_attr_t&#160;</td><td class="memItemRight" valign="bottom"><b>_pThreadAttribute</b></td></tr>
<tr class="separator:a98c08138675171bf4754628edc97ac63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aaaadf8213127834432b05942186b18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4aaaadf8213127834432b05942186b18"></a>
<a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_erThreadReturn</b></td></tr>
<tr class="separator:a4aaaadf8213127834432b05942186b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a77210c616eaa9c8810172687d1f77014"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77210c616eaa9c8810172687d1f77014"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>runFunction</b> (void *pPosixThread)</td></tr>
<tr class="separator:a77210c616eaa9c8810172687d1f77014"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classPosixThread.html">PosixThread</a> is a thread of execution in a program. To create a new thread of execution you must declare a class to be a subclass of <a class="el" href="classPosixThread.html">PosixThread</a>. This subclass should override the run method of class <a class="el" href="classPosixThread.html">PosixThread</a>. An instance of the subclass can then be allocated and started. For example, a thread that computes primes larger than a stated value could be written as follows: </p><pre class="fragment">class PrimeThread extends Thread {
    long minPrime;
    PrimeThread (long minPrime)
    {
        this. minPrime = minPrime;
    }
    public void run ()
    {
        compute primes larger than minPrime
        . . .
    }
}
</pre><p>The following code would then create a thread and start it running: </p><pre class="fragment">PrimeThread p = new PrimeThread (143);
p. init ();
p. start ();
p. finish ();
</pre><p>La libreria <a class="el" href="classPosixThread.html">PosixThread</a> semplifica la gestione di threads secondo lo standard POSIX fornendo una interfaccia object oriented semplice da utilizzare.</p>
<p>Un oggetto di tipo <a class="el" href="classPosixThread.html">PosixThread</a> rappresenta un thread non necessariamente in esecuzione.</p>
<p>Per creare ed eseguire un thread e' necessario:</p>
<ol type="1">
<li>dichiarare una classe come sottoclasse di <a class="el" href="classPosixThread.html">PosixThread</a> (es. ServerCorbaThread)</li>
<li>ridefinire nella sottoclasse il metodo run della classe <a class="el" href="classPosixThread.html">PosixThread</a></li>
<li>istanziare la sottoclasse (sctServerCorbaThread = new ServerCorbaThread)</li>
<li>inizializzare la sottoclasse (sctServerCorbaThread. init ())</li>
<li>far partire l'esecuzione del thread (sctServerCorbaThread. start ())</li>
</ol>
<p>Quando il thread termina e' necessario</p>
<ol type="1">
<li>eseguire la finish del thread (sctServerCorbaThread. finish ())</li>
<li>de-allocare il thread (delete sctServerCorbaThread)</li>
</ol>
<p>Le precedenti due operazione vengono eseguite automaticamente dalla libreria nel caso in cui il thread sia detached (vedi la descrizione del metodo <a class="el" href="classPosixThread.html#ac2efa899a1f3a094ca7f3491c3dd8a8b">PosixThread::detach</a> all'interno del Reference Manual).</p>
<p>La classe <a class="el" href="classPosixThread.html">PosixThread</a> mette a disposizione tutto cio' che e' possibile fare su di un thread (vedi Reference Manual).</p>
<p>La libreria permette anche di gestire la mutua esclusione. Come il nome stesso indica tale meccanismo serve per fare in modo che solo un thread acceda in un certo istante ad una certa zona di dati o, equivalentemente, esegue un certo spezzone di codice. La classe che ci viene in aiuto per risolvere questa situazione e' <a class="el" href="classPMutex.html">PMutex</a>. Essa possiede i metodi lock ed unLock esattamente per la gestione di 'regioni critiche'. Questi metodi devono essere chiamati risp.te all'inizio ed alla fine della regione critica e si comportano come un semaforo, garantendo che al piu' un solo thread si puo trovare in quella porzione di codice.</p>
<p>Nel caso in cui si desideri che un thread voglia sospendere la propria esecuzione aspettando che una certa condizione sia vera, e' necessario utilizzare le condition variable realizzate nella libreria dalla classe PConditionVariable. Ad esempio, un thread che legge da un buffer puo' volere aspettare che ci siano dei dati nel buffer senza essere costretto a dei cicli di attesa attiva.</p>
<p>Gli esempi che si trovano nella directory examples chiariranno l'uso di questa libreria. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2901391170273e771247e28007b47951"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosixThread::PosixThread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="af6630099d144f1362862f4421a9589d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PosixThread::~PosixThread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Call the finish() method in case it was not already called. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a47ecdacea37722cb68ecf5e8fc71edd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::cancel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows a thread to request that it terminate execution. This method sends a cancel to this thread. A cancel is a mechanism by which a calling thread informs this thread to terminate as quickly as possible. Issuing a cancel does not guarantee that the canceled thread receives or handles the cancel. The canceled thread can delay processing the cancel after receiving it. For instance, if a cancel arrives during an important operation, the canceled thread can continue if what it is doing cannot be interrupted at the point where the cancel is requested. Because of communications delays, the calling thread can only rely on the fact that a cancel eventually becomes pending in the designated thread (provided that the thread does not terminate beforehand). Furthermore, the calling thread has no guarantee that a pending cancel is to be delivered because delivery is controlled by the designated thread. </p>

<p>Reimplemented in <a class="el" href="classTracer.html#a1c3b5a0c056e0f98d3aa3e62496023c9">Tracer</a>, <a class="el" href="classSocketsPool.html#a0ca8e9e164d46cc6aee45323f19ebd9c">SocketsPool</a>, <a class="el" href="classScheduler.html#a8551a78947e4d8cb5d93ed1cc0ab160e">Scheduler</a>, <a class="el" href="classHttpPostThread.html#a7f35c09701ce092dcc6504322188c2fd">HttpPostThread</a>, <a class="el" href="classHttpGetThread.html#a9cb2e2e90debedd7345daf75e593529d">HttpGetThread</a>, <a class="el" href="classHTTPCacheManager.html#aae654101b5141106df7894a5e59f0e9f">HTTPCacheManager</a>, <a class="el" href="classLoadBalancer.html#adc69ce531c673ce0b1168e7ec4f6a86b">LoadBalancer</a>, <a class="el" href="classHttpServer.html#aab329490214c67b62c8837f3cac00a94">HttpServer</a>, and <a class="el" href="classBaseProcessor.html#af333227549f782150d29a8837913ea60">BaseProcessor</a>.</p>

</div>
</div>
<a class="anchor" id="ac2efa899a1f3a094ca7f3491c3dd8a8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::detach </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks a thread object for deletion. If thread has not terminated when this method is called, this method does not cause it to terminate. Call this routine when a thread object is no longer referenced. Additionally, call this routine for every thread that is created to ensure that storage for thread objects does not accumulate. You cannot join with a thread after the thread has been detached</p>
<p>After the calling of this method, is not necessary that the user calls the finish method because when the thread terminates, will be called the method finish and the thread object will be destroyed automatically. </p>

</div>
</div>
<a class="anchor" id="a5518cb0a6ca7fa8401f8129195f17b57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Terminates the calling thread. </p>

</div>
</div>
<a class="anchor" id="a91d79e057da03d98b2f50d0505abaa57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::getCurrentPriority </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>plCurrentPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the current priority of a thread. Parameters: plCurrentPriority - return value of the thread priority. </p>

</div>
</div>
<a class="anchor" id="a6a25d4027bfc99d96f359a4ef6fb02c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::getCurrentThread </td>
          <td>(</td>
          <td class="paramtype">pthread_t &amp;&#160;</td>
          <td class="paramname"><em>pThread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method allows a thread to obtain its own identifier. This value becomes meaningless when the thread object is deleted. </p>

</div>
</div>
<a class="anchor" id="ab043a6789909d7463b3a61dd57e33108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::getInheritScheduling </td>
          <td>(</td>
          <td class="paramtype">PThreadInheritScheduling_p&#160;</td>
          <td class="paramname"><em>pisInheritScheduling</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the inherit scheduling attribute Parameters: pisInheritScheduling - returns the inherit scheduling attribute value </p>

</div>
</div>
<a class="anchor" id="a8e4dcb96d7434b084436e601ba96d541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::getPriority </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>plPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the scheduling priority attribute. Parameters: plPriority - returns the scheduling priority attribute value </p>

</div>
</div>
<a class="anchor" id="a22e67d24081f87c257f6b7ffe1ad8e75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::getPThreadName </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pPThreadName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this thread's class name. Parameters: pPThreadName - thread name. </p>

</div>
</div>
<a class="anchor" id="a3f5a9e6da7c2aad005fcf9564536de8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::getSchedulingPolicy </td>
          <td>(</td>
          <td class="paramtype">PThreadSchedulingPolicy_p&#160;</td>
          <td class="paramname"><em>pspSchedulingPolicy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the value of the scheduling policy attribute Parameters: pspSchedulingPolicy - returns the value of the scheduling policy attribute </p>

</div>
</div>
<a class="anchor" id="a96135298bdeeb774752abce6cdf47e34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::getSleep </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulAdditionalMicroSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of lSeconds plus the specified number of microseconds (1/1000000 of secs). Parameters: lSeconds - the length of time to sleep in seconds lAdditionalMicroSeconds - additional microseconds to sleep. On SUN machine only the lSeconds parameter is considered. </p>

</div>
</div>
<a class="anchor" id="a25eeaa1b26df7f79b824cb1e3d9c7da2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::getStackSize </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>plStackSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the value of the stacksize attribute. The pthread_attr_getstacksize() routine obtains the minimum size (in bytes) of the stack for a thread created using the thread attributes object specified by the attr parameter. Parameters: plStackSize - returns the stacksize attribute value </p>

</div>
</div>
<a class="anchor" id="a788c5ceb2bfc97967770cb5dfa37a667"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::getThreadError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>perrThreadError</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this thread's error. Parameters: perrThreadError - return value of the thread error. </p>

</div>
</div>
<a class="anchor" id="a82fdda808044bfcfd81b9f8a4f9a713a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::getThreadIdentifier </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>pulThreadIdentifier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the thread identifier </p>

</div>
</div>
<a class="anchor" id="aa075c024237249d38f97e55e9cbd0ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::join </td>
          <td>(</td>
          <td class="paramtype">Error_p&#160;</td>
          <td class="paramname"><em>perrJoinError</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the calling thread to wait for the termination of this thread. A call to this method returns after this thread has terminated. The returned error is the error of the customized class. The perrJoinError argument contains the eventual error of the join method (eventual failure of the pthread_join API) </p>

</div>
</div>
<a class="anchor" id="a61712f976f5254a45c55eea8cd342f51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosixThread::operator long </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the thread identifier </p>

</div>
</div>
<a class="anchor" id="a48d1bd9a6abb5a67812a5bbb755f2b45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::setCancel </td>
          <td>(</td>
          <td class="paramtype">PThreadCancellationState_t&#160;</td>
          <td class="paramname"><em>csCancelability</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enables or disables the current thread's general cancelability. When general cancelability is set to THREADLIB_CANCEL_OFF, a cancel cannot be delivered to the thread. When a thread is created, the default general cancelability state is THREADLIB_CANCEL_ON. </p>

</div>
</div>
<a class="anchor" id="a28b2e7c68414996d2aeb79ff4c039ba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::setCancelType </td>
          <td>(</td>
          <td class="paramtype">PThreadCancellationType_t&#160;</td>
          <td class="paramname"><em>ctCancelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The thread's cancellation type determines when a thread could get cancelled. When the cancellation state is disabled, a thread's cancel- lation type is meaningless. The following cancellation types behave as follows when enabled:</p>
<p>THREADLIB_CANCEL_ASYNCHRONOUS Receipt of a pthread_cancel() call will result in an immediate cancellation.</p>
<p>THREADLIB_CANCEL_DEFERRED Cancellation will not occur until the target thread reaches a cancellation point (see below). Receipt of a pthread_cancel() call will result in an immediate cancellation at this cancellation point. The cancellation type is set to THREADLIB_CANCEL_DEFERRED, by default. </p>

</div>
</div>
<a class="anchor" id="a70b183f79c1ac18cfb8d4368601f8c13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::setCurrentPriority </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lNewCurrentPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the current priority of a thread. Parameters: lNewCurrentPriority - new thread priority (see setPriority). </p>

</div>
</div>
<a class="anchor" id="ab123363102c69a65ee3366bb99381149"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::setInheritScheduling </td>
          <td>(</td>
          <td class="paramtype">PThreadInheritScheduling_t&#160;</td>
          <td class="paramname"><em>isNewInheritScheduling</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the inherit scheduling attribute Parameters: lNewInheritScheduling - New value for the inherit scheduling attribute. Valid values are as follows:</p>
<p>THREADLIB_INHERITSCHED: this is the default value. The created thread inherits the current priority and scheduling policy of the thread calling. THREADLIB_DEFAULTSCHED: the created thread starts execution with the priority and scheduling policy stored in the thread attributes object. </p>

</div>
</div>
<a class="anchor" id="ace7ea1cfe3d623f149bdb391167a0ebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::setPriority </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lNewPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the scheduling priority attribute of thread creation. Parameters: lNewPriority - New value for the priority attribute. The priority attribute depends on scheduling policy.</p>
<p>With HPUX machine with CMA valid values fall within one of the following ranges:</p>
<p>THREADLIB_PRIOTHERMIN &lt;= lNewPriority &lt;= THREADLIB_PRIOTHERMAX (use with the THREADLIB_SCHEDOTHER policy) THREADLIB_PRIFIFOMIN &lt;= lNewPriority &lt;= THREADLIB_PRIFIFOMAX (use with the THREADLIB_SCHEDFIFO policy) THREADLIB_PRIRRMIN &lt;= lNewPriority &lt;= THREADLIB_PRIRRMAX (use with the THREADLIB_SCHEDRR policy) THREADLIB_PRIFGMINNP &lt;= lNewPriority &lt;= THREADLIB_PRIFGMAXNP (use with the THREAD_SCHEDFGNP policy) THREADLIB_PRIBGMINNP &lt;= lNewPriority &lt;= THREADLIB_PRIBGMAXNP (use with the THREADLIB_SCHEDBGNP policy)</p>
<p>The default priority is the midpoint between THREADLIB_PRIOTHERMIN and THREADLIB_PRIOTHERMAX.</p>
<p>To specify a minimum or maximum priority, use the appropriate symbol; for example, THREADLIB_PRIFIFOMIN or THREADLIB_PRIFIFOMAX. To specify a value between the minimum and maximum, use an appropriate arithmetic expression. For example, to specify a priority midway between the minimum and maximum for the Round Robin scheduling policy, specify the following concept using your programming language's syntax: pri_rr_mid = (THREADLIB_PRIRRMIN + THREADLIB_PRIRRMAX + 1) / 2 If your expression results in a value outside the range of minimum to maximum, an error results when you attempt to use it. By default, a created thread inherits the priority of the thread calling</p>
<p>With SUN or HP-UX 11 machine, there are functions as: int sched_get_priority_max(int policy); int sched_get_priority_min(int policy); </p>

</div>
</div>
<a class="anchor" id="a4611d1834f592b27d96729ebfdd8bfcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::setPThreadName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pPThreadName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this thread's class name. Parameters: pPThreadName - thread name. </p>

</div>
</div>
<a class="anchor" id="a21f2a4c995f0bdfac240f8973cebf4d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::setSchedulingPolicy </td>
          <td>(</td>
          <td class="paramtype">PThreadSchedulingPolicy_t&#160;</td>
          <td class="paramname"><em>spNewSchedulingPolicy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the scheduling policy attribute of thread creation Parameters: lNewSchedulingPolicy - New value for the scheduling policy attribute. Valid values are as follows:</p>
<p>THREADLIB_SCHEDFIFO: (First In, First Out) The highest-priority thread runs until it blocks. If there is more than one thread with the same priority, and that priority is the highest among other threads, the first thread to begin running continues until it blocks. THREADLIB_SCHEDRR: (Round Robin) The highest-priority thread runs until it blocks; however, threads of equal priority, if that priority is the highest among other threads, are timesliced. Timeslicing is a process in which threads alternate using available processors. THREADLIB_SCHEDOTHER: (Default) All threads are timesliced. SCHED_OTHER ensures that all threads, regardless of priority, receive some scheduling so that no thread is completely denied execution time. (However, THREADLIB_SCHEDOTHER threads can be denied execution time by THREADLIB_SCHEDFIFO or THREADLIB_SCHED_RR threads.) THREADLIB_SCHEDFGNP: (Foreground) Same as THREADLIB_SCHEDOTHER. Threads are timesliced and priorities can be modified dynamically by the scheduler to ensure fairness. THREADLIB_SCHEDBGNP: (Background) Ensures that all threads, regardless of priority, receive some scheduling. However, THREADLIB_SCHEDBGNP can be denied execution by THREADLIB_SCHEDFIFO or THREADLIB_SCHEDRR threads. </p>

</div>
</div>
<a class="anchor" id="a74fdfadeb522f9c7b1a9a5e02f4f8e07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::setStackSize </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lNewStackSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the stacksize attribute of thread creation Parameters: lNewStackSize - New value for the stacksize attribute. The stacksize parameter specifies the minimum size (in bytes) of the stack needed for a thread. The default value of the stacksize attribute is machine specific. Most compilers do not check for stack overflow. Ensure that your thread stack is large enough for anything that you call from the thread. </p>

</div>
</div>
<a class="anchor" id="affaca64786c9643d606b794133388d3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::start </td>
          <td>(</td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bToBeDetached</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Causes this thread to begin execution. The result is that two threads are running concurrently: the current thread (which returns from the call to the start method) and the other thread (which executes its run method).</p>
<p>bToBeDetached: If you have to detach a thread normally you will do: start () detach () If the thread is too fast potentially when you will call detach, the thread is already finished. In this case we could have memory leak. The parameter bToBeDetached make atomic the two calls avoiding any memory leak. </p>

</div>
</div>
<a class="anchor" id="a0438bf0771b6f07c082077bf3574c5dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::testCancel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requests delivery of a pending cancel to the current thread. The cancel is delivered only if a cancel is pending for the current thread and general cancel delivery is not currently disabled. (A thread disables delivery of cancels to itself by calling the setCancel () method.) </p>

</div>
</div>
<a class="anchor" id="a51daa00bef6a221fb1a4257ccbe95dd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PosixThread::yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method notifies the scheduler that the current thread is willing to release its processor to other threads of the same priority. (A thread releases its processor to a thread of a higher priority without calling this routine.) Causes the currently executing thread object to temporarily pause and allow other threads to execute. sched_yield() forces the running process to relinquish the processor until the process again becomes the head of its process list. Requeue current process in process list. The sched_yield() function forces the running process to relinquish the processor until it again becomes the head of its process list. It takes no arguments. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>PThread/src/<a class="el" href="PosixThread_8h_source.html">PosixThread.h</a></li>
<li>PThread/src/PosixThread.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
