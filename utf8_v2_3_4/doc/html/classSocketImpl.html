<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CatraLibraries: SocketImpl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CatraLibraries
   </div>
   <div id="projectbrief">CatraLibrariesisageneral-purposeC++framework.Itisplatformindependent(Unix,MAC,Windows,...)andprovidesclassestomanagePOSIXthreads,Sockets,SocketsConnectionManager,Tracer,Scheduler,EventsSet,Configurationfiles,HTTPCacheManager,SoftwareLoadBalancer,FTP,Tools(Buffers/Strings,DateTime,FileIO,FileReader,CPUUsage,Networks,Processes,Services,...),WebTools(HTTPGET,HTTPPOST,HTTPServer,...),Databaseaccess(Oracle,Sybase),,...</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classSocketImpl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SocketImpl Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="SocketImpl_8h_source.html">SocketImpl.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSocketImpl_1_1IPAddress.html">IPAddress</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a55960f22f1b6bc3bcee921965fe16e5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55960f22f1b6bc3bcee921965fe16e5d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SocketType</b> { <b>STREAM</b>, 
<b>DGRAM</b>
 }</td></tr>
<tr class="separator:a55960f22f1b6bc3bcee921965fe16e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae520b02741582221ba481bc1af4a2345"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae520b02741582221ba481bc1af4a2345"></a>
typedef enum SocketImpl::SocketType&#160;</td><td class="memItemRight" valign="bottom"><b>SocketType_t</b></td></tr>
<tr class="separator:ae520b02741582221ba481bc1af4a2345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f068adc0d23b8948c249b36a11e88a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0f068adc0d23b8948c249b36a11e88a"></a>
typedef enum <br class="typebreak" />
SocketImpl::SocketType *&#160;</td><td class="memItemRight" valign="bottom"><b>SocketType_p</b></td></tr>
<tr class="separator:ae0f068adc0d23b8948c249b36a11e88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908324638b7b91cbbbccd0507d060cab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a908324638b7b91cbbbccd0507d060cab"></a>
typedef struct <br class="typebreak" />
<a class="el" href="structSocketImpl_1_1IPAddress.html">SocketImpl::IPAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IPAddress_t</b></td></tr>
<tr class="separator:a908324638b7b91cbbbccd0507d060cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c63b80579b7262b83efbb39f76e7a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c63b80579b7262b83efbb39f76e7a9"></a>
typedef struct <br class="typebreak" />
<a class="el" href="structSocketImpl_1_1IPAddress.html">SocketImpl::IPAddress</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>IPAddress_p</b></td></tr>
<tr class="separator:af8c63b80579b7262b83efbb39f76e7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad1752a805105af67cb3df14888ae66df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#ad1752a805105af67cb3df14888ae66df">create</a> (SocketType_t stSocketType, unsigned long ulReceivingTimeoutInSeconds, unsigned long ulReceivingAdditionalTimeoutInMicroSeconds, unsigned long ulSendingTimeoutInSeconds, unsigned long ulSendingAdditionalTimeoutInMicroSeconds, Boolean_t bReuseAddr=false)</td></tr>
<tr class="separator:ad1752a805105af67cb3df14888ae66df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5439c8d72738cd807c528ab35310c2ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a5439c8d72738cd807c528ab35310c2ad">connect</a> (const char *pRemoteAddress, long lRemotePort, unsigned long ulConnectTimeoutInSecondsOnlyInCaseOfEINPROGRESS)</td></tr>
<tr class="separator:a5439c8d72738cd807c528ab35310c2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a8c888cb14a453d09dd00a04119656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#ae2a8c888cb14a453d09dd00a04119656">connect</a> (struct sockaddr_in *psckServerAddr, unsigned long ulConnectTimeoutInSecondsOnlyInCaseOfEINPROGRESS)</td></tr>
<tr class="separator:ae2a8c888cb14a453d09dd00a04119656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377f3dbd68c344e217da74bdbe4bc1ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a377f3dbd68c344e217da74bdbe4bc1ca">bind</a> (const char *pLocalAddress, long lLocalPort)</td></tr>
<tr class="separator:a377f3dbd68c344e217da74bdbe4bc1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2867a83f332b4ba078d5bbfba4e381b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a2867a83f332b4ba078d5bbfba4e381b5">listen</a> (long lClientsQueueLength)</td></tr>
<tr class="separator:a2867a83f332b4ba078d5bbfba4e381b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf12dd6d9f69e73aaa06884394491eef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#aaf12dd6d9f69e73aaa06884394491eef">acceptConnection</a> (<a class="el" href="classSocketImpl.html">SocketImpl</a> *pClientSocket)</td></tr>
<tr class="separator:aaf12dd6d9f69e73aaa06884394491eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3a09574fd6cd15e125abc22e6d8a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a6c3a09574fd6cd15e125abc22e6d8a4b">close</a> (void)</td></tr>
<tr class="separator:a6c3a09574fd6cd15e125abc22e6d8a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58320e3b0e7ba2f3e937373e33251c88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a58320e3b0e7ba2f3e937373e33251c88">setBlocking</a> (Boolean_t bBlocking)</td></tr>
<tr class="separator:a58320e3b0e7ba2f3e937373e33251c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acb601bc1e4bb3074ed4abeef9893ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a1acb601bc1e4bb3074ed4abeef9893ed">getBlocking</a> (Boolean_p pbBlocking)</td></tr>
<tr class="separator:a1acb601bc1e4bb3074ed4abeef9893ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ba93e30a4e650d4c534746afe289b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#af2ba93e30a4e650d4c534746afe289b7">setReceivingTimeout</a> (unsigned long ulReceivingTimeoutInSeconds, unsigned long ulReceivingAdditionalTimeoutInMicroSeconds)</td></tr>
<tr class="separator:af2ba93e30a4e650d4c534746afe289b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0d7b627ef03c12eef64e63ce28db05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#aee0d7b627ef03c12eef64e63ce28db05">setSendingTimeout</a> (unsigned long ulSendingTimeoutInSeconds, unsigned long ulSendingAdditionalTimeoutInMicroSeconds)</td></tr>
<tr class="separator:aee0d7b627ef03c12eef64e63ce28db05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d83a687cae390c2e4414ccfd193f38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a40d83a687cae390c2e4414ccfd193f38">setMaxSendBuffer</a> (unsigned long ulMaxSendBuffer)</td></tr>
<tr class="separator:a40d83a687cae390c2e4414ccfd193f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ab6290af68cbd7df8c4af87d78b0e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a29ab6290af68cbd7df8c4af87d78b0e3">setMaxReceiveBuffer</a> (unsigned long ulMaxReceiveBuffer)</td></tr>
<tr class="separator:a29ab6290af68cbd7df8c4af87d78b0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2885728f299e5fd909358789724a30fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a2885728f299e5fd909358789724a30fe">setLinger</a> (Boolean_t bLingerOnOff, unsigned long ulManySecondsToLingerFor)</td></tr>
<tr class="separator:a2885728f299e5fd909358789724a30fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d2f81419099342e8deb3ed136c9d20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a41d2f81419099342e8deb3ed136c9d20">setKeepAlive</a> (Boolean_t bKeepAlive)</td></tr>
<tr class="separator:a41d2f81419099342e8deb3ed136c9d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f134390ceabb65c84253a9e84a3a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a915f134390ceabb65c84253a9e84a3a1">setNoDelay</a> (Boolean_t bNoDelay)</td></tr>
<tr class="separator:a915f134390ceabb65c84253a9e84a3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8857f956c24feaa8623d662c2bbe3a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#af8857f956c24feaa8623d662c2bbe3a4">isReadyForReading</a> (Boolean_p pbIsReadyForReading, unsigned long ulSecondsToWait, unsigned long ulAdditionalMicrosecondsToWait)</td></tr>
<tr class="separator:af8857f956c24feaa8623d662c2bbe3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49955cc59e4a2b49e4720a9641dd6994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a49955cc59e4a2b49e4720a9641dd6994">isReadyForWriting</a> (Boolean_p pbIsReadyForWriting, unsigned long ulSecondsToWait, unsigned long ulAdditionalMicrosecondsToWait)</td></tr>
<tr class="separator:a49955cc59e4a2b49e4720a9641dd6994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d18d8d345d93c63ec2bb1445e4f7130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a4d18d8d345d93c63ec2bb1445e4f7130">isThereException</a> (Boolean_p pbIsThereException, unsigned long ulSecondsToWait, unsigned long ulAdditionalMicrosecondsToWait)</td></tr>
<tr class="separator:a4d18d8d345d93c63ec2bb1445e4f7130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884d1e886f774fdee2fb1e14585864e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a884d1e886f774fdee2fb1e14585864e0">waitForBuffer</a> (const char *pBufferToWait, long lTimeoutInSeconds, long lAdditionalTimeoutInMicroSeconds)</td></tr>
<tr class="separator:a884d1e886f774fdee2fb1e14585864e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53427142ce745a08c7fa9acc2cda875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#ab53427142ce745a08c7fa9acc2cda875">vacuum</a> (long lTimeoutInSeconds, long lAdditionalTimeoutInMicroSeconds)</td></tr>
<tr class="separator:ab53427142ce745a08c7fa9acc2cda875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab471ac205f7ae9b30c0a1326beb6198c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#ab471ac205f7ae9b30c0a1326beb6198c">vacuumByTelnet</a> (long lTimeoutInSeconds, long lAdditionalTimeoutInMicroSeconds)</td></tr>
<tr class="separator:ab471ac205f7ae9b30c0a1326beb6198c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1ae8ae00f78c5c48692e7d54c7cdc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a7a1ae8ae00f78c5c48692e7d54c7cdc6">read</a> (void *pvBuffer, unsigned long *pulBufferLength, Boolean_t bReadingCheckToBePerformed, unsigned long ulSecondsToWait, unsigned long ulAdditionalMicrosecondsToWait, Boolean_t bOneShotRead=false, Boolean_t bRemoveDataFromSocket=true)</td></tr>
<tr class="separator:a7a1ae8ae00f78c5c48692e7d54c7cdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249563ac0fa8a3851503277d139d6bca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a249563ac0fa8a3851503277d139d6bca">readLine</a> (char *pBuffer, unsigned long ulBufferLength, unsigned long *pulCharsRead, unsigned long ulTimeoutInSeconds, unsigned long ulAdditionalTimeoutInMicroSeconds)</td></tr>
<tr class="separator:a249563ac0fa8a3851503277d139d6bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639b329509df297fcd7fc7d0f4d2b33c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a639b329509df297fcd7fc7d0f4d2b33c">readLineByTelnet</a> (char *pBuffer, long lBufferLength, long lTimeoutInSeconds=-1, long lAdditionalTimeoutInMicroSeconds=0)</td></tr>
<tr class="separator:a639b329509df297fcd7fc7d0f4d2b33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ff9444eec6dcb0d687b2fbb11a5efa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a08ff9444eec6dcb0d687b2fbb11a5efa">readByTelnet</a> (char *pBuffer, unsigned long *pulBufferLength, Boolean_t bOneShotRead)</td></tr>
<tr class="separator:a08ff9444eec6dcb0d687b2fbb11a5efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbc2e823dbcf121dbf38705e1eaf2ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#a9fbc2e823dbcf121dbf38705e1eaf2ac">readLineFromJava</a> (char *pBuffer, long lBufferLength)</td></tr>
<tr class="separator:a9fbc2e823dbcf121dbf38705e1eaf2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa910e51fa2458746bfbc31f1913bb280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#aa910e51fa2458746bfbc31f1913bb280">writeString</a> (const char *pString, Boolean_t bWritingCheckToBePerformed, unsigned long ulSecondsToWait, unsigned long ulAdditionalMicrosecondsToWait, const char *pRemoteAddress=(const char *) NULL, long lRemotePort=-1)</td></tr>
<tr class="separator:aa910e51fa2458746bfbc31f1913bb280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d1c830cd24230a2016be4a6f220321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#af9d1c830cd24230a2016be4a6f220321">write</a> (void *pvBuffer, long lBufferLength, Boolean_t bWritingCheckToBePerformed, unsigned long ulSecondsToWait, unsigned long ulAdditionalMicrosecondsToWait, const char *pRemoteAddress=(const char *) NULL, long lRemotePort=-1)</td></tr>
<tr class="separator:af9d1c830cd24230a2016be4a6f220321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81454e55d48782741b6062e9b5b54bb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81454e55d48782741b6062e9b5b54bb9"></a>
<a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getRemoteAddress</b> (char *pRemoteAddress, unsigned long ulBufferLength)</td></tr>
<tr class="separator:a81454e55d48782741b6062e9b5b54bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f17acadb72a30636c1a7dada20a854"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31f17acadb72a30636c1a7dada20a854"></a>
<a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getRemotePort</b> (long *plRemotePort)</td></tr>
<tr class="separator:a31f17acadb72a30636c1a7dada20a854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055a60bed611c9a67746209d0aa285b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a055a60bed611c9a67746209d0aa285b1"></a>
<a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getLocalAddress</b> (char *pLocalAddress, unsigned long ulBufferLength)</td></tr>
<tr class="separator:a055a60bed611c9a67746209d0aa285b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96e4303fd014d057771ad684db4110b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae96e4303fd014d057771ad684db4110b"></a>
<a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getLocalPort</b> (long *plLocalPort)</td></tr>
<tr class="separator:ae96e4303fd014d057771ad684db4110b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a84713b25bebeaf900221c5147a72a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5a84713b25bebeaf900221c5147a72a"></a>
<a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getReceivingTimeouts</b> (unsigned long *pulReceivingTimeoutInSeconds, unsigned long *pulReceivingAdditionalTimeoutInMicroSeconds)</td></tr>
<tr class="separator:ae5a84713b25bebeaf900221c5147a72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf672309870d176e873c05d843e81339"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf672309870d176e873c05d843e81339"></a>
<a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getSendingTimeouts</b> (unsigned long *pulSendingTimeoutInSeconds, unsigned long *pulSendingAdditionalTimeoutInMicroSeconds)</td></tr>
<tr class="separator:adf672309870d176e873c05d843e81339"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a742c7cb1bd7b2de8ffb3b230822e9593"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a742c7cb1bd7b2de8ffb3b230822e9593"></a>
static <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getIPAddressesList</b> (std::vector&lt; <a class="el" href="structSocketImpl_1_1IPAddress.html">IPAddress_t</a> &gt; *pvIPAddresses)</td></tr>
<tr class="separator:a742c7cb1bd7b2de8ffb3b230822e9593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae127f3653d79ba5391c1d0b7faf155d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSocketImpl.html#aae127f3653d79ba5391c1d0b7faf155d">getMACAddress</a> (const char *pNetworkIdentifier, unsigned char pucMACAddress[6])</td></tr>
<tr class="separator:aae127f3653d79ba5391c1d0b7faf155d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a82d702e3045a934348a4f6ea6e3b4d36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82d702e3045a934348a4f6ea6e3b4d36"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SocketImpl</b> (const <a class="el" href="classSocketImpl.html">SocketImpl</a> &amp;t)</td></tr>
<tr class="separator:a82d702e3045a934348a4f6ea6e3b4d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a31a8280d16f626a0ff9afa0f5e2c6ca6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31a8280d16f626a0ff9afa0f5e2c6ca6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SocketsPool</b></td></tr>
<tr class="separator:a31a8280d16f626a0ff9afa0f5e2c6ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class <a class="el" href="classSocketImpl.html">SocketImpl</a> is a common superclass of all classes that actually implement sockets. It is used to create both client and server sockets. A "plain" socket implements these methods exactly as described, without attempting to go through a firewall or proxy. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaf12dd6d9f69e73aaa06884394491eef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::acceptConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSocketImpl.html">SocketImpl</a> *&#160;</td>
          <td class="paramname"><em>pClientSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Accepts a connection. Parameters: pClientSocket - the accepted connection. </p>

</div>
</div>
<a class="anchor" id="a377f3dbd68c344e217da74bdbe4bc1ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::bind </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pLocalAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lLocalPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds this socket to the specified port number. Parameters: pLocalAddress - local address to handle this traffic. If it is NULL or "" it will be used the default local address lLocalPort - the port number. </p>

</div>
</div>
<a class="anchor" id="a6c3a09574fd6cd15e125abc22e6d8a4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes this socket. </p>

</div>
</div>
<a class="anchor" id="a5439c8d72738cd807c528ab35310c2ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pRemoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lRemotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulConnectTimeoutInSecondsOnlyInCaseOfEINPROGRESS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects this socket to the specified port on the named host. Parameters: pRemoteAddress - the name of the remote host. lRemotePort - the port number. timeouts parameters: see the comments inside the connect </p>

</div>
</div>
<a class="anchor" id="ae2a8c888cb14a453d09dd00a04119656"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::connect </td>
          <td>(</td>
          <td class="paramtype">struct sockaddr_in *&#160;</td>
          <td class="paramname"><em>psckServerAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulConnectTimeoutInSecondsOnlyInCaseOfEINPROGRESS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects this socket to the specified sockaddr. Parameters: psckServerAddr - <a class="el" href="classSocket.html">Socket</a> address </p>

</div>
</div>
<a class="anchor" id="ad1752a805105af67cb3df14888ae66df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::create </td>
          <td>(</td>
          <td class="paramtype">SocketType_t&#160;</td>
          <td class="paramname"><em>stSocketType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulReceivingTimeoutInSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulReceivingAdditionalTimeoutInMicroSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSendingTimeoutInSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSendingAdditionalTimeoutInMicroSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bReuseAddr</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates either a stream or a datagram socket. Parameters: stSocketType - socket type ulReceivingTimeoutIn* - Specify the receiving timeout until reporting an error. 0 to disable the timeout ulSendingTimeoutIn* - Specify the sending timeout until reporting an error. 0 to disable the timeout bReuseAddr - specifies the reuse of the address</p>
<p>Remark: The <a class="el" href="classSocketImpl.html">SocketImpl</a>:: setBlocking works only if the Receiving parameter is set to 0. </p>

</div>
</div>
<a class="anchor" id="a1acb601bc1e4bb3074ed4abeef9893ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::getBlocking </td>
          <td>(</td>
          <td class="paramtype">Boolean_p&#160;</td>
          <td class="paramname"><em>pbBlocking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the blocking flag. Parameters: pbBlocking - </p>

</div>
</div>
<a class="anchor" id="aae127f3653d79ba5391c1d0b7faf155d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::getMACAddress </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pNetworkIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>pucMACAddress</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The pNetworkIdentifier depends from the OS. For Windows this parameter is not used and the first card he retrieved is used. For unix environment this parameter must be filled with the string identifying the network (i.e.: "eth0") </p>

</div>
</div>
<a class="anchor" id="af8857f956c24feaa8623d662c2bbe3a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::isReadyForReading </td>
          <td>(</td>
          <td class="paramtype">Boolean_p&#160;</td>
          <td class="paramname"><em>pbIsReadyForReading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSecondsToWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulAdditionalMicrosecondsToWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if in the socket there is something to read false otherwise Parameters: pbIsReadyForReading - ulSecondsToWait - ulAdditionalMicrosecondsToWait - </p>

</div>
</div>
<a class="anchor" id="a49955cc59e4a2b49e4720a9641dd6994"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::isReadyForWriting </td>
          <td>(</td>
          <td class="paramtype">Boolean_p&#160;</td>
          <td class="paramname"><em>pbIsReadyForWriting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSecondsToWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulAdditionalMicrosecondsToWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if in the socket there is something to write false otherwise Parameters: pbIsReadyForWriting - ulSecondsToWait - ulAdditionalMicrosecondsToWait - </p>

</div>
</div>
<a class="anchor" id="a4d18d8d345d93c63ec2bb1445e4f7130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::isThereException </td>
          <td>(</td>
          <td class="paramtype">Boolean_p&#160;</td>
          <td class="paramname"><em>pbIsThereException</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSecondsToWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulAdditionalMicrosecondsToWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if in the socket there is exception false otherwise Parameters: pbIsThereException - ulSecondsToWait - ulAdditionalMicrosecondsToWait - </p>

</div>
</div>
<a class="anchor" id="a2867a83f332b4ba078d5bbfba4e381b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::listen </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lClientsQueueLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the maximum queue length for incoming connection indications (a request to connect) to the count argument. If a connection indication arrives when the queue is full, the connection is refused. Parameters: lClientsQueueLength - the maximum length of the queue. </p>

</div>
</div>
<a class="anchor" id="a7a1ae8ae00f78c5c48692e7d54c7cdc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>pulBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bReadingCheckToBePerformed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSecondsToWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulAdditionalMicrosecondsToWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bOneShotRead</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bRemoveDataFromSocket</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads data. Parameters: pvBuffer - buffer to read pulBufferLength - the buffer length bReadingCheckToBePerformed - indicates if must be call internally isReadyForReading before to read ulSecondsToWait and ulAdditionalMicrosecondsToWait - are parameters for isReadyForReading. Not used if bReadingCheckToBePerformed is false bOneShotRead - can it perform only one read If this method returns: SCK_READ_EOFREACHED error if the socket connection is down SCK_NOTHINGTOREAD error if there is nothing to read (only if bReadingCheckToBePerformed is true) </p>

</div>
</div>
<a class="anchor" id="a08ff9444eec6dcb0d687b2fbb11a5efa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::readByTelnet </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>pulBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bOneShotRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads data for a specified period using the telnet protocol. Parameters: pBuffer - buffer cointaining the line lBufferLength - the buffer length lTimeoutInSeconds - seconds available to read a line lAdditionalTimeoutInMicroSeconds - microseconds available to read a line </p>

</div>
</div>
<a class="anchor" id="a249563ac0fa8a3851503277d139d6bca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::readLine </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>pulCharsRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulTimeoutInSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulAdditionalTimeoutInMicroSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a line of data. Parameters: pBuffer - buffer cointaining the line and finishing with the '\0' character ulBufferLength - the buffer length pulCharsRead - chars read ulTimeoutInSeconds - seconds available to read a line ulAdditionalTimeoutInMicroSeconds - microseconds available to read a line If this method returns the SCK_READ_EOFREACHED error, that means the socket connection is down</p>
<p>If ulTimeoutInSeconds and ulAdditionalTimeoutInMicroSeconds are both zero, the internal <a class="el" href="classSocketImpl.html">SocketImpl</a>:: read method will not perform any check if there is something to read before reading. </p>

</div>
</div>
<a class="anchor" id="a639b329509df297fcd7fc7d0f4d2b33c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::readLineByTelnet </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lTimeoutInSeconds</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lAdditionalTimeoutInMicroSeconds</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Eliminata perchè la readLines è una read.</p>
<p>Reads lines of data until there are lines in the socket or the buffer is filled completely. Parameters: pBuffer - buffer cointaining the lines lBufferLength - the buffer length plCharsRead - chars read lTimeoutInSeconds - seconds available to read the lines lAdditionalTimeoutInMicroSeconds - microseconds available to read the lines pNewLine - this is what the method use to separate the lines. Examples are "\n", "\r\n", ... If this method returns the SCK_READ_EOFREACHED error, that means the socket connection is down <a class="el" href="classError.html">Error</a> readLines (char *pBuffer, long lBufferLength, long *plCharsRead, long lTimeoutInSeconds, long lAdditionalTimeoutInMicroSeconds, const char *pNewLine = "\n"); Reads a line of data using the telnet protocol. Parameters: pBuffer - buffer cointaining the line lBufferLength - the buffer length lTimeoutInSeconds - seconds available to read a line lAdditionalTimeoutInMicroSeconds - microseconds available to read a line </p>

</div>
</div>
<a class="anchor" id="a9fbc2e823dbcf121dbf38705e1eaf2ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::readLineFromJava </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lBufferLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a JAVA line of data. In Java each char is 2 bytes. Parameters: pBuffer - buffer cointaining the line lBufferLength - the buffer length If this method returns the SCK_READ_EOFREACHED error, that means the socket connection is down </p>

</div>
</div>
<a class="anchor" id="a58320e3b0e7ba2f3e937373e33251c88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::setBlocking </td>
          <td>(</td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bBlocking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the blocking flag. Parameters: bBlocking - true for blocking some methods (for example read or acceptConnection) false otherwise</p>
<p>Remark: The <a class="el" href="classSocketImpl.html">SocketImpl</a>:: setBlocking works only if the Receiving parameter (<a class="el" href="classServerSocket.html">ServerSocket</a>:: init or <a class="el" href="classClientSocket.html">ClientSocket</a>:: init) is set to 0. </p>

</div>
</div>
<a class="anchor" id="a41d2f81419099342e8deb3ed136c9d20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::setKeepAlive </td>
          <td>(</td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bKeepAlive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable sending of keep-alive messages on connection-oriented sockets. Questa opzione abilita o disabilita l'invio di pacchetti di tipo keepalives su una socket di tipo stream permettendo di rilevare eventuali problemi su una connessione su cui non si stanno trasmettendo dati. E' disabilitata di default. I keepalives sono pacchetti che non contengono dati ma che costringono lo scack TCP-IP che li riceve a inviare un riscontro al mittente. Inviare periodicamente tali pacchetti su una connessione momentaneamente inutilizzata (su cui non si sta ne trasmettendo ne ricevendo) permette di verificarne la validità. Il rovescio della medaglia è ovviamente la larghezza di banda sprecata per implementare tale meccanismo. In caso di errore (ad es. nessuno dei keepalives trasmessi è stato riscontrato) verrà notificato un evento FD_CLOSE contenete l'errore (WSAECONNABORTED in questo caso) alla procedura di finestra dell'applicazione. Parameters: bKeepAlive - </p>

</div>
</div>
<a class="anchor" id="a2885728f299e5fd909358789724a30fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::setLinger </td>
          <td>(</td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bLingerOnOff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulManySecondsToLingerFor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When the close or shutdown is called, the OS does not make the socket available but it sets the socket state to TIME_WAIT. OS will maintain this state for a time between 1 and 4 minutes before to make the socket available. From Internet:</p>
<p>"Because of these potential problems with TIME_WAIT assassinations, one should not avoid the TIME_WAIT state by setting the SO_LINGER option to send an RST instead of the normal TCP connection termination (FIN/ACK/FIN/ACK). The TIME_WAIT state is there for a reason; it's your friend and it's there to help you :-)"</p>
<p>At the same time, if a connection (socket) is open and closed continuously (stress test), the number of TIME_WAIT will increase and we could reach easily the max number of sockets.</p>
<p>setLinger, when enabled, a close(2) or shutdown(2) will not return until all queued messages for the socket have been successfully sent or the linger timeout has been reached. Otherwise, the call returns immediately and the closing is done in the background. When the socket is closed as part of exit(2), it always lingers in the background. </p>

</div>
</div>
<a class="anchor" id="a29ab6290af68cbd7df8c4af87d78b0e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::setMaxReceiveBuffer </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulMaxReceiveBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the maximum socket receive buffer in bytes Parameters: ulMaxReceiveBuffer - </p>

</div>
</div>
<a class="anchor" id="a40d83a687cae390c2e4414ccfd193f38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::setMaxSendBuffer </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulMaxSendBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the maximum socket send buffer in bytes Parameters: ulMaxReceiveBuffer - </p>

</div>
</div>
<a class="anchor" id="a915f134390ceabb65c84253a9e84a3a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::setNoDelay </td>
          <td>(</td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bNoDelay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable TCP_NODELAY on connection-oriented sockets. Questa opzione abilita o disabilita l'algoritmo di Nagle: quando è disabilitata (il suo valore è false) tale algoritmo è abilitato. L'algoritmo di Nagle è usato per ridurre il traffico della rete senza ridurre le prestazioni. Opera evitando di trasmettere i dati non appena questi si rendono disponibili ma aspettando di riempire il pacchetto prima di spedirlo. Disabilitare tale algoritmo potrebbe avere un impatto negativo sulle prestazioni della rete per cui dovrebbe essere fatto solo nel caso in cui il ritardo introdotto da esso nell'inoltro dei dati penalizzi eccessivamente le prestazioni della propria applicazione.</p>
<p>TCP connections run with Nagle's algorithm enabled by default. This is a cooperative way of limiting bandwidth consumption, by having the sender only send at a rate the recipient can handle. The algorithm adapts, but it does ramp up slowly. Set TCP_NODELAY on a socket if you do not want it.</p>
<p>Parameters: bTCPNodelay - </p>

</div>
</div>
<a class="anchor" id="af2ba93e30a4e650d4c534746afe289b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::setReceivingTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulReceivingTimeoutInSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulReceivingAdditionalTimeoutInMicroSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the receiving timeout of the socket Parameters: ulReceivingTimeoutInSeconds - ulReceivingAdditionalTimeoutInMicroSeconds - </p>

</div>
</div>
<a class="anchor" id="aee0d7b627ef03c12eef64e63ce28db05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::setSendingTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSendingTimeoutInSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSendingAdditionalTimeoutInMicroSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the sending timeout of the socket Parameters: ulSendingTimeoutInSeconds - ulSendingAdditionalTimeoutInMicroSeconds - </p>

</div>
</div>
<a class="anchor" id="ab53427142ce745a08c7fa9acc2cda875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::vacuum </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lTimeoutInSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lAdditionalTimeoutInMicroSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used to vacuum unwanted data from the incomming data stream and drop it. Parameters: lTimeoutInSeconds - seconds available to vacuum the chars read lAdditionalTimeoutInMicroSeconds - microseconds available to vacuum the chars read </p>

</div>
</div>
<a class="anchor" id="ab471ac205f7ae9b30c0a1326beb6198c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::vacuumByTelnet </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lTimeoutInSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lAdditionalTimeoutInMicroSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used to vacuum unwanted data from the incomming data stream using the telnet protocol and drop it. Parameters: lTimeoutInSeconds - seconds available to vacuum the chars read lAdditionalTimeoutInMicroSeconds - microseconds available to vacuum the chars read </p>

</div>
</div>
<a class="anchor" id="a884d1e886f774fdee2fb1e14585864e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::waitForBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pBufferToWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lTimeoutInSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lAdditionalTimeoutInMicroSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for the appearance of the specified string in the data stream Return errNoError if the string is detected, the SCK_SOCKETIMPL_TIMEOUTEXPIRED error if timeout expired Parameters: pBufferToWait - lTimeoutInSeconds - seconds available to wait the buffer lAdditionalTimeoutInMicroSeconds - microseconds available to read a line </p>

</div>
</div>
<a class="anchor" id="af9d1c830cd24230a2016be4a6f220321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::write </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bWritingCheckToBePerformed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSecondsToWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulAdditionalMicrosecondsToWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pRemoteAddress</em> = <code>(const&#160;char&#160;*)&#160;NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lRemotePort</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a buffer of data for STREAM socket. Parameters: pvBuffer - buffer to be written lBufferLength - the buffer length bWritingCheckToBePerformed - indicates if must be call internally isReadyForWriting before to write ulSecondsToWait and ulAdditionalMicrosecondsToWait - are parameters for isReadyForWriting. Not used if bWritingCheckToBePerformed is false pRemoteAddress - it is necessary if we have a DGRAM socket lRemotePort - it is necessary if we have a DGRAM socket </p>

</div>
</div>
<a class="anchor" id="aa910e51fa2458746bfbc31f1913bb280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> SocketImpl::writeString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bWritingCheckToBePerformed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSecondsToWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulAdditionalMicrosecondsToWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pRemoteAddress</em> = <code>(const&#160;char&#160;*)&#160;NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lRemotePort</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a string of data. Parameters: pString - string to be written bWritingCheckToBePerformed - indicates if must be call internally isReadyForWriting before to write ulSecondsToWait and ulAdditionalMicrosecondsToWait - are parameters for isReadyForWriting. Not used if bWritingCheckToBePerformed is false pRemoteAddress - it is necessary if we have a DGRAM socket lRemotePort - it is necessary if we have a DGRAM socket </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Socket/src/<a class="el" href="SocketImpl_8h_source.html">SocketImpl.h</a></li>
<li>Socket/src/SocketImpl.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
