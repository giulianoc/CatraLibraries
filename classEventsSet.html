<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CatraLibraries: EventsSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CatraLibraries
   </div>
   <div id="projectbrief">CatraLibraries is a general-purpose platform independent (Unix, MAC, Windows, ...) C++ framework.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classEventsSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EventsSet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="EventsSet_8h_source.html">EventsSet.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EventsSet:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classEventsSet.png" usemap="#EventsSet_map" alt=""/>
  <map id="EventsSet_map" name="EventsSet_map">
<area href="classCMEventsSet.html" alt="CMEventsSet" shape="rect" coords="0,56,88,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEventsSet_1_1DestinationEvent.html">DestinationEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEventsSet_1_1EventTypeInfo.html">EventTypeInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEventsSet_1_1ltstr.html">ltstr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab2fde28983294cd5b81445497f82857f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventsSet.html#ab2fde28983294cd5b81445497f82857f">init</a> (Boolean_t bConditionVariablesToBeUsed, unsigned long ulEventTypeNumberPreAllocated)</td></tr>
<tr class="separator:ab2fde28983294cd5b81445497f82857f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0a594ec620510009b4227bbeb5524d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventsSet.html#a8e0a594ec620510009b4227bbeb5524d">finish</a> (void)</td></tr>
<tr class="separator:a8e0a594ec620510009b4227bbeb5524d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad99c27676a6d6c010bf0452aab9140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventsSet.html#a2ad99c27676a6d6c010bf0452aab9140">getFreeEvent</a> (unsigned long ulEventTypeIndex, Event_p *pevEvent)</td></tr>
<tr class="separator:a2ad99c27676a6d6c010bf0452aab9140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0935b281a9596a499675a857b99a4420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventsSet.html#a0935b281a9596a499675a857b99a4420">releaseEvent</a> (unsigned long ulEventTypeIndex, Event_p pevEvent)</td></tr>
<tr class="separator:a0935b281a9596a499675a857b99a4420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecab27ea4a36ebc14801842d92cb929"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventsSet.html#a8ecab27ea4a36ebc14801842d92cb929">addEvent</a> (Event_p pevEvent)</td></tr>
<tr class="separator:a8ecab27ea4a36ebc14801842d92cb929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b695de70e7ee76a281f20bcafc2d0d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventsSet.html#a0b695de70e7ee76a281f20bcafc2d0d4">addDestination</a> (const char *pDestination)</td></tr>
<tr class="separator:a0b695de70e7ee76a281f20bcafc2d0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb52df7902cdfeb97fa4083fe19821e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventsSet.html#acb52df7902cdfeb97fa4083fe19821e8">deleteEvent</a> (Event_p pevEvent)</td></tr>
<tr class="separator:acb52df7902cdfeb97fa4083fe19821e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4da78765568177eea3c10072d2b0b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventsSet.html#a7f4da78765568177eea3c10072d2b0b5">getFirstEvent</a> (Buffer_p pbDestination, Event_p *pevEvent, Boolean_p pbEventExpired, Boolean_t bBlocking, unsigned long ulSecondsToBlock, unsigned long ulAdditionalMilliSecondsToBlock)</td></tr>
<tr class="separator:a7f4da78765568177eea3c10072d2b0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b16e194bb2e5f262d2c23eb312bb6b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventsSet.html#a4b16e194bb2e5f262d2c23eb312bb6b6">getAndRemoveFirstEvent</a> (Buffer_p pbDestination, Event_p *pevEvent, Boolean_t bBlocking, unsigned long ulSecondsToBlock, unsigned long ulAdditionalMilliSecondsToBlock)</td></tr>
<tr class="separator:a4b16e194bb2e5f262d2c23eb312bb6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a850a9c7122e8f4d9990bff4da4c0292a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a850a9c7122e8f4d9990bff4da4c0292a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EventsSetStatus</b> { <b>EVSET_EVENTSSETBUILDED</b>, 
<b>EVSET_EVENTSSETINITIALIZED</b>
 }</td></tr>
<tr class="separator:a850a9c7122e8f4d9990bff4da4c0292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f53a9f7e08e7827675a0efc3811566"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22f53a9f7e08e7827675a0efc3811566"></a>
typedef enum <br class="typebreak" />
EventsSet::EventsSetStatus&#160;</td><td class="memItemRight" valign="bottom"><b>EventsSetStatus_t</b></td></tr>
<tr class="separator:a22f53a9f7e08e7827675a0efc3811566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ee2895bd3abb7739f05f9d31486812"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6ee2895bd3abb7739f05f9d31486812"></a>
typedef enum <br class="typebreak" />
EventsSet::EventsSetStatus *&#160;</td><td class="memItemRight" valign="bottom"><b>EventsSetStatus_p</b></td></tr>
<tr class="separator:aa6ee2895bd3abb7739f05f9d31486812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb90daacdf68c12b418dd9444c1f356"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cb90daacdf68c12b418dd9444c1f356"></a>
typedef std::multimap<br class="typebreak" />
&lt; unsigned long long, Event_p, <br class="typebreak" />
<a class="el" href="structEventsSet_1_1ltstr.html">ltstr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EventsMultiMap_t</b></td></tr>
<tr class="separator:a8cb90daacdf68c12b418dd9444c1f356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd052ad4afe7bfa94fc77c1bfbfc950"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cd052ad4afe7bfa94fc77c1bfbfc950"></a>
typedef std::multimap<br class="typebreak" />
&lt; unsigned long long, Event_p, <br class="typebreak" />
<a class="el" href="structEventsSet_1_1ltstr.html">ltstr</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>EventsMultiMap_p</b></td></tr>
<tr class="separator:a8cd052ad4afe7bfa94fc77c1bfbfc950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e882c9e76244d529b6f7192a6b97a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26e882c9e76244d529b6f7192a6b97a3"></a>
typedef struct <br class="typebreak" />
<a class="el" href="structEventsSet_1_1DestinationEvent.html">EventsSet::DestinationEvent</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DestinationEvent_t</b></td></tr>
<tr class="separator:a26e882c9e76244d529b6f7192a6b97a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7666df6ac5901ce5bdea13f2911b0c27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7666df6ac5901ce5bdea13f2911b0c27"></a>
typedef struct <br class="typebreak" />
<a class="el" href="structEventsSet_1_1DestinationEvent.html">EventsSet::DestinationEvent</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>DestinationEvent_p</b></td></tr>
<tr class="separator:a7666df6ac5901ce5bdea13f2911b0c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb1d1f64c2bdc8eb2c96a9e9eb0d3a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eb1d1f64c2bdc8eb2c96a9e9eb0d3a3"></a>
typedef my_hash_map&lt; Buffer_p, <br class="typebreak" />
<a class="el" href="structEventsSet_1_1DestinationEvent.html">DestinationEvent_p</a>, <br class="typebreak" />
BufferHasher, BufferCmp &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EventsSetHashMap_t</b></td></tr>
<tr class="separator:a5eb1d1f64c2bdc8eb2c96a9e9eb0d3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1648122aa8abbe9678ba0d6f9f3a127"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1648122aa8abbe9678ba0d6f9f3a127"></a>
typedef my_hash_map&lt; Buffer_p, <br class="typebreak" />
<a class="el" href="structEventsSet_1_1DestinationEvent.html">DestinationEvent_p</a>, <br class="typebreak" />
BufferHasher, BufferCmp &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>EventsSetHashMap_p</b></td></tr>
<tr class="separator:af1648122aa8abbe9678ba0d6f9f3a127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8222c4838d4a793273057884dca0d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a8222c4838d4a793273057884dca0d9"></a>
typedef struct <br class="typebreak" />
<a class="el" href="structEventsSet_1_1EventTypeInfo.html">EventsSet::EventTypeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EventTypeInfo_t</b></td></tr>
<tr class="separator:a7a8222c4838d4a793273057884dca0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb335aefbc41fadcbe237b967aa073c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cb335aefbc41fadcbe237b967aa073c"></a>
typedef struct <br class="typebreak" />
<a class="el" href="structEventsSet_1_1EventTypeInfo.html">EventsSet::EventTypeInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>EventTypeInfo_p</b></td></tr>
<tr class="separator:a3cb335aefbc41fadcbe237b967aa073c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9ed9ecad7d9619581f1d00d59692c2f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ed9ecad7d9619581f1d00d59692c2f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EventsSet</b> (const <a class="el" href="classEventsSet.html">EventsSet</a> &amp;)</td></tr>
<tr class="separator:a9ed9ecad7d9619581f1d00d59692c2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739de47ef3467928a432eb24c24f8b41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a739de47ef3467928a432eb24c24f8b41"></a>
<a class="el" href="classEventsSet.html">EventsSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classEventsSet.html">EventsSet</a> &amp;)</td></tr>
<tr class="separator:a739de47ef3467928a432eb24c24f8b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5913d297eed994c3885eee0433b1adad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventsSet.html#a5913d297eed994c3885eee0433b1adad">allocateMoreFreeUserEvents</a> (unsigned long ulEventTypeIndex, unsigned long *_pulPreAllocatedEventsNumber, std::vector&lt; Event_p &gt; *pvFreeEvents, std::vector&lt; Event_p &gt; *pvPointersToAllocatedEvents)</td></tr>
<tr class="separator:a5913d297eed994c3885eee0433b1adad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09f23afa6bf129a4350787d9d9fbe50"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventsSet.html#ab09f23afa6bf129a4350787d9d9fbe50">deleteAllocatedEvents</a> (unsigned long ulEventTypeIndex, std::vector&lt; Event_p &gt; *pvPointersToAllocatedEvents)</td></tr>
<tr class="separator:ab09f23afa6bf129a4350787d9d9fbe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7b5289f1036b472f3748b9d67ee30265"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b5289f1036b472f3748b9d67ee30265"></a>
EventsSetStatus_t&#160;</td><td class="memItemRight" valign="bottom"><b>_essEventsSetStatus</b></td></tr>
<tr class="separator:a7b5289f1036b472f3748b9d67ee30265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04ececca974662492a797a4a74efadd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae04ececca974662492a797a4a74efadd"></a>
PMutex_t&#160;</td><td class="memItemRight" valign="bottom"><b>_evSetMutex</b></td></tr>
<tr class="separator:ae04ececca974662492a797a4a74efadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6d431377b46a499298bb15fcd1581d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf6d431377b46a499298bb15fcd1581d"></a>
Boolean_t&#160;</td><td class="memItemRight" valign="bottom"><b>_bConditionVariablesToBeUsed</b></td></tr>
<tr class="separator:adf6d431377b46a499298bb15fcd1581d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58e7aa20020efbf098506f56b9839c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa58e7aa20020efbf098506f56b9839c3"></a>
BufferHasher_p&#160;</td><td class="memItemRight" valign="bottom"><b>_psHasher</b></td></tr>
<tr class="separator:aa58e7aa20020efbf098506f56b9839c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede301554b7d25ecfafef2d92d7cce48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aede301554b7d25ecfafef2d92d7cce48"></a>
BufferCmp_p&#160;</td><td class="memItemRight" valign="bottom"><b>_psComparer</b></td></tr>
<tr class="separator:aede301554b7d25ecfafef2d92d7cce48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348f0db84c4f72464a9ee5d462cf30de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a348f0db84c4f72464a9ee5d462cf30de"></a>
EventsSetHashMap_p&#160;</td><td class="memItemRight" valign="bottom"><b>_pesmEventsSetHashMap</b></td></tr>
<tr class="separator:a348f0db84c4f72464a9ee5d462cf30de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ff2f585c5b22161b6f1e5992e61629"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16ff2f585c5b22161b6f1e5992e61629"></a>
PMutex_t&#160;</td><td class="memItemRight" valign="bottom"><b>_mtFreeEvents</b></td></tr>
<tr class="separator:a16ff2f585c5b22161b6f1e5992e61629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f337ce8c829644a9856cfa667fd1bc5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f337ce8c829644a9856cfa667fd1bc5"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>_ulNumberOfDifferentEventTypeToManage</b></td></tr>
<tr class="separator:a7f337ce8c829644a9856cfa667fd1bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260fd221a32520b3ce64ca1990a18f3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a260fd221a32520b3ce64ca1990a18f3f"></a>
<a class="el" href="structEventsSet_1_1EventTypeInfo.html">EventTypeInfo_p</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_petiEventTypeInfo</b></td></tr>
<tr class="separator:a260fd221a32520b3ce64ca1990a18f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>La classe <a class="el" href="classEventsSet.html">EventsSet</a> e' stata pensata per essere usata in un ambiente in cui esistono threads che producono eventi e threads che consumano eventi. Tutti i threads avranno visibilita' di uno o piu' oggetti del tipo <a class="el" href="classEventsSet.html">EventsSet</a> in modo che i threads possano comunicare tramite eventi. E' questo il motivo per cui i metodi piu' utilizzati di questa classe, addEvent (chiamato dal thread che produce l'evento) e getAndRemoveFirstEvent (chiamato dal thread che consuma l'evento), sono stati pensati per essere molto veloci. Infatti, un oggetto di tipo <a class="el" href="classEventsSet.html">EventsSet</a> partiziona tutti gli eventi inseriti secondo il loro destinatario. Inoltre, per ogni partizione, gli eventi sono ordinati secondo la loro chiave. Non possono coesiste due eventi con la stessa chiave. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0b695de70e7ee76a281f20bcafc2d0d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> EventsSet::addDestination </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pDestination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a destination to the <a class="el" href="classEventsSet.html">EventsSet</a>. You could add before a destination because if a thread calls getAndRemoveFirstEvent with a destination that it is not added yet (this tipically happens at the beginning when no events are added yet), the getAndRemoveFirstEvent method returns immediatelly without waiting any timeout. That will cause a big usage of the CPU. </p>

</div>
</div>
<a class="anchor" id="a8ecab27ea4a36ebc14801842d92cb929"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> EventsSet::addEvent </td>
          <td>(</td>
          <td class="paramtype">Event_p&#160;</td>
          <td class="paramname"><em>pevEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserisce il puntatore all'evento indicato dal parametro pevEvent, nell'insieme. Questo metodo potrebbe essere chiamato da un thread che vuole 'spedire' un evento ad un altro thread. L'<a class="el" href="classEventsSet.html">EventsSet</a> non supporta chiavi duplicate per cui non possono coesistere due eventi con la stessa chiave </p>

</div>
</div>
<a class="anchor" id="a5913d297eed994c3885eee0433b1adad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> EventsSet::allocateMoreFreeUserEvents </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulEventTypeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>_pulPreAllocatedEventsNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Event_p &gt; *&#160;</td>
          <td class="paramname"><em>pvFreeEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Event_p &gt; *&#160;</td>
          <td class="paramname"><em>pvPointersToAllocatedEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is called each time there is a request of a new free event and there is no free event available. The default behaviour is to allocate an amount of free events (EVSET_DEFAULTNUMBEROFNEWFREEEVENTSALLOCATED) of Event_t type.</p>
<p>This method can be redefined to allocate the correct event type established by the ulEventTypeIndex parameter. Since the library cannot know the event type to allocate (because it will be a derived class of Event_t) it calls this method to give to the user the opportunity to redefine it and allocate the correct event. If that method is redefined, also the deleteAllocatedEvents method must be redefined.</p>
<p>ulEventTypeIndex: specifies the event type from which it is necessary the allocation pulFreeEventsNumberAllocated: it is an output parameter in order to provide to the library the information about the number of events allocated pevPreAllocatedEvents: it is an output parameter to provide to the library the pointer to the events allocated</p>
<p>Inside this method it is possible also to put a cap on the events to be allocated and if this cap is reached it can return the EVSET_EVENTSSET_REACHEDMAXIMUMEVENTSTOALLOCATE error. </p>

<p>Reimplemented in <a class="el" href="classCMEventsSet.html#a29fdd757dc1eb4ecf026a75a637db377">CMEventsSet</a>.</p>

</div>
</div>
<a class="anchor" id="ab09f23afa6bf129a4350787d9d9fbe50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> EventsSet::deleteAllocatedEvents </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulEventTypeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Event_p &gt; *&#160;</td>
          <td class="paramname"><em>pvPointersToAllocatedEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is called from the finish method to delete the allocated events saved inside the pvPointersToAllocatedEvents vector.</p>
<p>This method can be redefined to delete the correct event type established by the ulEventTypeIndex parameter. Since the library cannot know the event type to deallocate (because it will be a derived class of Event_t) it calls this method to give to the user the opportunity to deallocate the correct event.</p>
<p>If that method is redefined, also the allocateMoreFreeUserEvents method must be redefined.</p>
<p>ulEventTypeIndex: specifies the event type from which it is necessary the allocation pevPreAllocatedEvents: it is the vector containing all the pointers to the allocated events by the allocateMoreFreeUserEvents method </p>

<p>Reimplemented in <a class="el" href="classCMEventsSet.html#aa57daaca97cb012538169389e757f203">CMEventsSet</a>.</p>

</div>
</div>
<a class="anchor" id="acb52df7902cdfeb97fa4083fe19821e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> EventsSet::deleteEvent </td>
          <td>(</td>
          <td class="paramtype">Event_p&#160;</td>
          <td class="paramname"><em>pevEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rimuove il puntatore all'evento indicato dal parametro pevEvent, dall'insieme.</p>
<p>Nota bene che l'evento non viene de-allocato, ma viene semplicemente rimosso il puntatore all'evento, dall'insieme. </p>

</div>
</div>
<a class="anchor" id="a8e0a594ec620510009b4227bbeb5524d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> EventsSet::finish </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method deallocate also all the events allocated by the allocateFreeUserEvents method. </p>

</div>
</div>
<a class="anchor" id="a4b16e194bb2e5f262d2c23eb312bb6b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> EventsSet::getAndRemoveFirstEvent </td>
          <td>(</td>
          <td class="paramtype">Buffer_p&#160;</td>
          <td class="paramname"><em>pbDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Event_p *&#160;</td>
          <td class="paramname"><em>pevEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bBlocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSecondsToBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulAdditionalMilliSecondsToBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Questo metodo ritorna il puntatore al primo evento. Ricorda che l'<a class="el" href="classEventsSet.html">EventsSet</a> è ordinato socondo la chiave dell'evento Il metodo rimuove anche l'evento ritornato.</p>
<p>Nota bene che l'evento non viene de-allocato, ma viene semplicemente rimosso il puntatore dall'insieme.</p>
<p>Esso potrebbe essere chiamato dal thread che e' in attesa di un evento per conoscere la sua prossima operazione da fare.</p>
<p>Il parametro bBlocking indica se il metodo deve rimanere bloccato al suo interno finchè non viene inserito un evento nel caso in cui non ci siano eventi nel set. I parametri ulSecondsToBlock e ulAdditionalMilliSecondsToBlock vengono considerati nel caso che bBlocking sia true. </p>

</div>
</div>
<a class="anchor" id="a7f4da78765568177eea3c10072d2b0b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> EventsSet::getFirstEvent </td>
          <td>(</td>
          <td class="paramtype">Buffer_p&#160;</td>
          <td class="paramname"><em>pbDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Event_p *&#160;</td>
          <td class="paramname"><em>pevEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean_p&#160;</td>
          <td class="paramname"><em>pbEventExpired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bBlocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSecondsToBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulAdditionalMilliSecondsToBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Questo metodo ritorna il puntatore al primo evento. Ricorda che l'<a class="el" href="classEventsSet.html">EventsSet</a> è ordinato secondo la chiave dell'evento.</p>
<p>Il parametro bBlocking indica se il metodo deve rimanere bloccato al suo interno finchè non viene inserito un evento nel caso in cui non ci siano eventi nel set. I parametri ulSecondsToBlock e ulAdditionalMilliSecondsToBlock vengono considerati nel caso che bBlocking sia true. </p>

</div>
</div>
<a class="anchor" id="a2ad99c27676a6d6c010bf0452aab9140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> EventsSet::getFreeEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulEventTypeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Event_p *&#160;</td>
          <td class="paramname"><em>pevEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a free pre-allocated event.</p>
<p>The free event required must be of the type represented by the ulEventTypeIndex parameter. </p>

</div>
</div>
<a class="anchor" id="ab2fde28983294cd5b81445497f82857f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> EventsSet::init </td>
          <td>(</td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bConditionVariablesToBeUsed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulEventTypeNumberPreAllocated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inizializza un oggetto di tipo <a class="el" href="classEventsSet.html">EventsSet</a>. Un oggetto di tipo <a class="el" href="classEventsSet.html">EventsSet</a> partiziona tutti gli eventi inseriti secondo il loro destinatario.</p>
<p>This class can preallocates all the events used by the application. The ulEventTypeNumberPreAllocated parameter indicates how many different type of events must be managed. The class needs that information because it will allocates an equivalent number of vectors each one to save all the free events of the specified type.</p>
<p>This class calls the allocateFreeUserEvents method each time it needs a new free event to allocate.</p>
<p>ulEventTypeNumberPreAllocated: it represents the number of all the different events type (class derived from Event_t) and managed by this class. The default (-1) means that, by default, it handles only Event_t event type. </p>

</div>
</div>
<a class="anchor" id="a0935b281a9596a499675a857b99a4420"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> EventsSet::releaseEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulEventTypeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Event_p&#160;</td>
          <td class="paramname"><em>pevEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>L'<a class="el" href="classEventsSet.html">EventsSet</a> riceve l'evento precedentemente avuto con getFreeEvent.</p>
<p>The ulEventTypeIndex parameter specifies the type of the event that will be releasing. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>EventsSet/src/<a class="el" href="EventsSet_8h_source.html">EventsSet.h</a></li>
<li>EventsSet/src/EventsSet.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
