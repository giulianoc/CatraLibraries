<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CatraLibraries: PMutex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CatraLibraries
   </div>
   <div id="projectbrief">CatraLibrariesisageneral-purposeC++framework.Itisplatformindependent(Unix,MAC,Windows,...)andprovidesclassestomanagePOSIXthreads,Sockets,SocketsConnectionManager,Tracer,Scheduler,EventsSet,Configurationfiles,HTTPCacheManager,SoftwareLoadBalancer,FTP,Tools(Buffers/Strings,DateTime,FileIO,FileReader,CPUUsage,Networks,Processes,Services,...),WebTools(HTTPGET,HTTPPOST,HTTPServer,...),Databaseaccess(Oracle,Sybase),,...</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPMutex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PMutex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="PMutex_8h_source.html">PMutex.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaa2f863fdffbf6582b0c685d54a83452"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa2f863fdffbf6582b0c685d54a83452"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PMutexType</b> { <b>MUTEX_FAST</b> = PTHREAD_MUTEX_NORMAL, 
<b>MUTEX_ERRORCHECK</b> = PTHREAD_MUTEX_ERRORCHECK, 
<b>MUTEX_RECURSIVE</b> = PTHREAD_MUTEX_RECURSIVE, 
<b>MUTEX_NONRECURSIVE</b> = PTHREAD_MUTEX_DEFAULT
 }</td></tr>
<tr class="separator:aaa2f863fdffbf6582b0c685d54a83452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197b69dd160cf4bb178918d1cb9dddec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a197b69dd160cf4bb178918d1cb9dddec"></a>
typedef enum PMutex::PMutexType&#160;</td><td class="memItemRight" valign="bottom"><b>PMutexType_t</b></td></tr>
<tr class="separator:a197b69dd160cf4bb178918d1cb9dddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab019c1762580ea6456475481d16012e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab019c1762580ea6456475481d16012e3"></a>
typedef enum PMutex::PMutexType *&#160;</td><td class="memItemRight" valign="bottom"><b>PMutexType_p</b></td></tr>
<tr class="separator:ab019c1762580ea6456475481d16012e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2327db7f0ce7108c6d6982bf8ce802a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPMutex.html#a2327db7f0ce7108c6d6982bf8ce802a3">PMutex</a> (void)</td></tr>
<tr class="separator:a2327db7f0ce7108c6d6982bf8ce802a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93579e615a2ad987e5b2da43e6f2fc1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPMutex.html#a93579e615a2ad987e5b2da43e6f2fc1f">~PMutex</a> (void)</td></tr>
<tr class="separator:a93579e615a2ad987e5b2da43e6f2fc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f67058b3904721006c95a6a7db31fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPMutex.html#a33f67058b3904721006c95a6a7db31fb">init</a> (PMutexType_t pMutexType)</td></tr>
<tr class="separator:a33f67058b3904721006c95a6a7db31fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0392202f9bebefb9b91d3316399d795f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPMutex.html#a0392202f9bebefb9b91d3316399d795f">finish</a> (void)</td></tr>
<tr class="separator:a0392202f9bebefb9b91d3316399d795f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4f79ca898a6c4aac5b3aaf2f173253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPMutex.html#a5f4f79ca898a6c4aac5b3aaf2f173253">lock</a> (void)</td></tr>
<tr class="separator:a5f4f79ca898a6c4aac5b3aaf2f173253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefed4657817eac6691e11eec29ed9aef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPMutex.html#aefed4657817eac6691e11eec29ed9aef">unLock</a> (void)</td></tr>
<tr class="separator:aefed4657817eac6691e11eec29ed9aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26860330c20d30abc254dc42ab10f82d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPMutex.html#a26860330c20d30abc254dc42ab10f82d">tryLock</a> (Boolean_p pbIsLockable)</td></tr>
<tr class="separator:a26860330c20d30abc254dc42ab10f82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab3639d95c39d06e475198caac8da9c83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3639d95c39d06e475198caac8da9c83"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PMutex</b> (const <a class="el" href="classPMutex.html">PMutex</a> &amp;m)</td></tr>
<tr class="separator:ab3639d95c39d06e475198caac8da9c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebabf993412250bcbfcc45261ba36c46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPMutex.html#aebabf993412250bcbfcc45261ba36c46">operator pthread_mutex_t *</a> ()</td></tr>
<tr class="separator:aebabf993412250bcbfcc45261ba36c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab3fd5b9ccacd6f8331de904057a4c7a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3fd5b9ccacd6f8331de904057a4c7a4"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PCondition</b></td></tr>
<tr class="separator:ab3fd5b9ccacd6f8331de904057a4c7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Rapresents the POSIX mutex. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2327db7f0ce7108c6d6982bf8ce802a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMutex::PMutex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a93579e615a2ad987e5b2da43e6f2fc1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMutex::~PMutex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0392202f9bebefb9b91d3316399d795f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PMutex::finish </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a mutex. </p>

</div>
</div>
<a class="anchor" id="a33f67058b3904721006c95a6a7db31fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PMutex::init </td>
          <td>(</td>
          <td class="paramtype">PMutexType_t&#160;</td>
          <td class="paramname"><em>pMutexType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a mutex. Parameters: pMutexType - specifies the mutex type attribute.</p>
<p>In the HPUX machine with CMA thread: This method creates a mutex and initializes it to the unlocked state. If the thread that called this routine terminates, the created mutex is not automatically deallocated, because it is considered shared among multiple threads.</p>
<p>Valid values are MUTEX_FAST (default), MUTEX_RECURSIVE, and MUTEX_NONRECURSIVE</p>
<p>A fast mutex is locked and unlocked in the fastest manner possible. A fast mutex can only be locked (obtained) once. All subsequent calls to lock () cause the calling thread to block until the mutex is freed by the thread that owns it. If the thread that owns the mutex attempts to lock it again, the thread waits for itself to release the mutex (causing a deadlock).</p>
<p>A recursive mutex can be locked more than once by the same thread without causing that thread to deadlock. In other words, a single thread can make consecutive calls to pthread_mutex_lock() without blocking. The thread must then call unlock () the same number of times as it called lock () before another thread can lock the mutex.</p>
<p>A nonrecursive mutex is locked only once by a thread, like a fast mutex. If the thread tries to lock the mutex again without first unlocking it, the thread receives an error. Thus, nonrecursive mutexes are more informative than fast mutexes because fast mutexes block in such a case, leaving it up to you to determine why the thread no longer executes. Also, if someone other than the owner tries to unlock a nonrecursive mutex, an error is returned.</p>
<p>In the HP-UX 11 machine (POSIX.1-1996 standard) Mutexes can be created with four different types. The type of a mutex is contained in the type attribute of the mutex attributes object. Valid values for the type attribute are: PTHREAD_MUTEX_NORMAL This type of mutex does not provide deadlock detection. A thread attempting to relock this mutex without first unlocking it shall deadlock. An error is not returned to the caller. Attempting to unlock a mutex locked by a different thread results in undefined behavior. Attempting to unlock an unlocked mutex results in undefined behavior. PTHREAD_MUTEX_ERRORCHECK This type of mutex provides error checking. An owner field is maintained. Only the mutex lock owner shall successfully unlock this mutex. A thread attempting to relock this mutex shall return with an error. A thread attempting to unlock a mutex locked by a different thread shall return with an error. A thread attempting to unlock an unlocked mutex shall return with an error. This type of mutex is useful for debugging. PTHREAD_MUTEX_RECURSIVE Deadlock cannot occur with this type of mutex. An owner field is maintained. A thread attempting to relock this mutex shall successfully lock the mutex. Multiple locks of this mutex shall require the same number of unlocks to release the mutex before another thread can lock the mutex. A thread attempting to unlock a mutex locked by a different thread shall return with an error. A thread attempting to unlock an unlocked mutex shall return with an error. PTHREAD_MUTEX_DEFAULT Attempting to recursively lock a mutex of this type results in undefined behavior. Attempting to unlock a mutex locked by a different thread results in undefined behavior. Attempting to unlock an unlocked mutex results in undefined behavior. An implementation shall be allowed to map this mutex to one of the other mutex types.</p>
<p>In the SUN (SPARC) machine: Mutual exclusion locks (mutexes) prevent multiple threads from simultaneously executing critical sections of code which access shared data (that is, mutexes are used to seri- alize the execution of threads). All mutexes must be glo- bal. A successful call for a mutex lock will cause another thread that is also trying to lock the same mutex to block until the owner thread unlocks it. Threads within the same process or within other processes can share mutexes. Mutexes are either intra-process or inter-process, depending upon the argument passed implicitly or explicitly to the initialization of that mutex. For inter-process synchronization, a mutex needs to be allo- cated in memory shared between these processes.</p>
<p>Valid values are MUTEX_PROCESS_PRIVATE (default), and MUTEX_PROCESS_SHARED If the process-shared attribute is MUTEX_PROCESS_PRIVATE, only threads created within the same process as the thread that initialized the mutex can access the mutex. If threads of differing processes attempt to access the mutex, the behavior is unpredictable. </p>

</div>
</div>
<a class="anchor" id="a5f4f79ca898a6c4aac5b3aaf2f173253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PMutex::lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks an unlocked mutex. If the mutex is locked when a thread calls this routine, the thread waits for the mutex to become available. The thread that has locked a mutex becomes its current owner and remains the owner until the same thread has unlocked it. In the SUN machine Mutual exclusion locks (mutexes) prevent multiple threads from simultaneously executing critical sections of code which access shared data (that is, mutexes are used to seri- alize the execution of threads). All mutexes must be glo- bal. A successful call for a mutex lock will cause another thread that is also trying to lock the same mutex to block until the owner thread unlocks it via unLock (). Threads within the same process or within other processes can share mutexes.</p>
<p>Mutexes can synchronize threads within the same process or in other processes. Mutexes can be used to synchronize threads between processes if the mutexes are allocated in writable memory and shared among the cooperating processes (see mmap(2)), and have been initialized for this task.</p>
<p>In the HP-UX 11 machine (POSIX.1-1996 standard) If the mutex type is PTHREAD_MUTEX_NORMAL, deadlock detection is not provided. Attempting to relock the mutex causes deadlock. If a thread attempts to unlock a mutex that it has not locked or a mutex which is unlocked, undefined behavior results. If the mutex type is PTHREAD_MUTEX_ERRORCHECK, the mutex maintains the concept of an owner. If a thread attempts to relock a mutex that it has already locked, an error shall be returned. If a thread attempts to unlock a mutex that it has not locked or a mutex that is unlocked, an error shall be returned. If the mutex type is PTHREAD_MUTEX_RECURSIVE, then the mutex maintains the concept of an owner and a lock count. When a thread successfully acquires a mutex for the first time, the count field shall be set to one. Every time a thread relocks this mutex, the count field shall be incremented by one. Each time the thread unlocks the mutex, the count field shall be decremented by one. When the count field reaches zero, the mutex shall become available for other threads to acquire. If a thread attempts to unlock a mutex that it has not locked, an error shall be returned. If the mutex type is PTHREAD_MUTEX_DEFAULT, attempting to recursively lock the mutex results in undefined behavior. Attempting to unlock the mutex if it was not locked by the calling thread results in undefined behavior. Attempting to unlocked the mutex if it is not locked results </p>

</div>
</div>
<a class="anchor" id="aebabf993412250bcbfcc45261ba36c46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PMutex::operator pthread_mutex_t * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method convert this mutex object into its pthread_mutex_t structure Return the pthread_mutex_t pointer. </p>

</div>
</div>
<a class="anchor" id="a26860330c20d30abc254dc42ab10f82d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PMutex::tryLock </td>
          <td>(</td>
          <td class="paramtype">Boolean_p&#160;</td>
          <td class="paramname"><em>pbIsLockable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks a mutex. If the specified mutex is locked when a thread calls this routine, the calling thread does not wait for the mutex to become available.</p>
<p>In the HP-UX 11 machine (POSIX.1-1996 standard) If the mutex type is PTHREAD_MUTEX_NORMAL, deadlock detection is not provided. Attempting to relock the mutex causes deadlock. If a thread attempts to unlock a mutex that it has not locked or a mutex which is unlocked, undefined behavior results. If the mutex type is PTHREAD_MUTEX_ERRORCHECK, the mutex maintains the concept of an owner. If a thread attempts to relock a mutex that it has already locked, an error shall be returned. If a thread attempts to unlock a mutex that it has not locked or a mutex that is unlocked, an error shall be returned. If the mutex type is PTHREAD_MUTEX_RECURSIVE, then the mutex maintains the concept of an owner and a lock count. When a thread successfully acquires a mutex for the first time, the count field shall be set to one. Every time a thread relocks this mutex, the count field shall be incremented by one. Each time the thread unlocks the mutex, the count field shall be decremented by one. When the count field reaches zero, the mutex shall become available for other threads to acquire. If a thread attempts to unlock a mutex that it has not locked, an error shall be returned. </p>

</div>
</div>
<a class="anchor" id="aefed4657817eac6691e11eec29ed9aef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PMutex::unLock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks a mutex. See lock (). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>PThread/src/<a class="el" href="PMutex_8h_source.html">PMutex.h</a></li>
<li>PThread/src/PMutex.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
