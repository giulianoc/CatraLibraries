<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CatraLibraries: PCondition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CatraLibraries
   </div>
   <div id="projectbrief">CatraLibrariesisageneral-purposeC++framework.Itisplatformindependent(Unix,MAC,Windows,...)andprovidesclassestomanagePOSIXthreads,Sockets,SocketsConnectionManager,Tracer,Scheduler,EventsSet,Configurationfiles,HTTPCacheManager,SoftwareLoadBalancer,FTP,Tools(Buffers/Strings,DateTime,FileIO,FileReader,CPUUsage,Networks,Processes,Services,...),WebTools(HTTPGET,HTTPPOST,HTTPServer,...),Databaseaccess(Oracle,Sybase),,...</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classPCondition-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PCondition Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="PCondition_8h_source.html">PCondition.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a515a9474fa4a37e46cd3164645c3d0df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a515a9474fa4a37e46cd3164645c3d0df"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PConditionType</b> { <b>COND_DEFAULT</b>
 }</td></tr>
<tr class="separator:a515a9474fa4a37e46cd3164645c3d0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe56d8c7378b1970077a4be418573403"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe56d8c7378b1970077a4be418573403"></a>
typedef enum <br class="typebreak" />
PCondition::PConditionType&#160;</td><td class="memItemRight" valign="bottom"><b>PConditionType_t</b></td></tr>
<tr class="separator:abe56d8c7378b1970077a4be418573403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef5aa6a79f7ac299438e55bc022841b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ef5aa6a79f7ac299438e55bc022841b"></a>
typedef enum <br class="typebreak" />
PCondition::PConditionType *&#160;</td><td class="memItemRight" valign="bottom"><b>PConditionType_p</b></td></tr>
<tr class="separator:a7ef5aa6a79f7ac299438e55bc022841b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02edcfab64dd0fd4e02c6a4fe3f6b239"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCondition.html#a02edcfab64dd0fd4e02c6a4fe3f6b239">PCondition</a> (void)</td></tr>
<tr class="separator:a02edcfab64dd0fd4e02c6a4fe3f6b239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94abbf927061970115f9a7f5d9e4bf47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCondition.html#a94abbf927061970115f9a7f5d9e4bf47">~PCondition</a> (void)</td></tr>
<tr class="separator:a94abbf927061970115f9a7f5d9e4bf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddc8309d28a6d32c3c731261d22971d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCondition.html#aeddc8309d28a6d32c3c731261d22971d">init</a> (PConditionType_t pConditionType)</td></tr>
<tr class="separator:aeddc8309d28a6d32c3c731261d22971d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc32006254865a49e20f198500b7830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCondition.html#a9bc32006254865a49e20f198500b7830">finish</a> (void)</td></tr>
<tr class="separator:a9bc32006254865a49e20f198500b7830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54a79a687d2ef850bf94d59f536d7a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCondition.html#aa54a79a687d2ef850bf94d59f536d7a6">wait</a> (PMutex_p pMutex)</td></tr>
<tr class="separator:aa54a79a687d2ef850bf94d59f536d7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123401a262d6c157db5cc6caeec39b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCondition.html#a123401a262d6c157db5cc6caeec39b94">timedWait</a> (PMutex_p pMutex, unsigned long ulSeconds, unsigned long ulAdditionalMilliSeconds)</td></tr>
<tr class="separator:a123401a262d6c157db5cc6caeec39b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86089362f9f2fcf4c3570c46b92f0fd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCondition.html#a86089362f9f2fcf4c3570c46b92f0fd7">signal</a> (void)</td></tr>
<tr class="separator:a86089362f9f2fcf4c3570c46b92f0fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3283699c99fb10bc76140ccd3c657e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCondition.html#a6a3283699c99fb10bc76140ccd3c657e">broadcast</a> (void)</td></tr>
<tr class="separator:a6a3283699c99fb10bc76140ccd3c657e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a01ae8b392ff006f7b60f337cf88e8ceb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01ae8b392ff006f7b60f337cf88e8ceb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PCondition</b> (const <a class="el" href="classPCondition.html">PCondition</a> &amp;c)</td></tr>
<tr class="separator:a01ae8b392ff006f7b60f337cf88e8ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7501a23c388ad14cfc3d23ea29e3a5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCondition.html#ab7501a23c388ad14cfc3d23ea29e3a5b">operator pthread_cond_t *</a> ()</td></tr>
<tr class="separator:ab7501a23c388ad14cfc3d23ea29e3a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Condition class represents a condition variable. Once the variable has been created, threads can wait for the variable to "come true", or signal one or all the waiting threads to continue. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a02edcfab64dd0fd4e02c6a4fe3f6b239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCondition::PCondition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a94abbf927061970115f9a7f5d9e4bf47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCondition::~PCondition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6a3283699c99fb10bc76140ccd3c657e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PCondition::broadcast </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wakes all threads that are waiting on this condition variable. It simply calls the POSIX pthread_cond_broadcast primitive. Wakes all threads that are waiting on a condition variable. </p>

</div>
</div>
<a class="anchor" id="a9bc32006254865a49e20f198500b7830"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PCondition::finish </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a condition variable. </p>

</div>
</div>
<a class="anchor" id="aeddc8309d28a6d32c3c731261d22971d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PCondition::init </td>
          <td>(</td>
          <td class="paramtype">PConditionType_t&#160;</td>
          <td class="paramname"><em>pConditionType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a condition variable. Occasionally, a thread running within a mutex needs to wait for an event, in which case it blocks or sleeps. When a thread is waiting for another thread to communicate its disposition, it uses a condition variable in conjunction with a mutex. Although a mutex is exclusive and the code it protects is shareable (at certain moments), condition vari- ables enable the synchronization of differing events that share a mutex, but not necessarily data. Several condition variables may be used by threads to signal each other when a task is complete, which then allows the next waiting thread to take ownership of the mutex.</p>
<p>In SUN machine Condition variables and mutexes should be global. Condition variables that are allocated in writable memory can syn- chronize threads among processes if they are shared by the cooperating processes (see mmap(2)) and are initialized for this purpose.</p>
<p>The pConditionType can assume the PTHREAD_PROCESS_PRIVATE value, which only allows the condition variable to be operated upon by threads created within the same process as the thread that initialized the condition variable. If threads from other processes try to operate on this condition variable, the behavior is undefined.</p>
<p>The pConditionType may be set to PTHREAD_PROCESS_SHARED , which allows a condition variable to be operated upon by any thread with access to the memory allocated to the condition variable, even if the condition variable is allocated in memory that is shared by multiple processes. </p>

</div>
</div>
<a class="anchor" id="ab7501a23c388ad14cfc3d23ea29e3a5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PCondition::operator pthread_cond_t * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method convert this Condition object into its pthread_cond_t structure Returns the pthread_cond_t pointer. </p>

</div>
</div>
<a class="anchor" id="a86089362f9f2fcf4c3570c46b92f0fd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PCondition::signal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wakes one thread that is waiting on a condition variable. It simply calls the POSIX pthread_cond_signal primitive. Wakes one thread that is waiting on a condition variable. Calling this method implies that data guarded by the associated mutex has changed so that it is possible for a single waiting thread to proceed. Call this method when any thread waiting on the specified condition variable might find its predicate true, but only one thread needs to proceed. The scheduling policy determines which thread is awakened. </p>

</div>
</div>
<a class="anchor" id="a123401a262d6c157db5cc6caeec39b94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PCondition::timedWait </td>
          <td>(</td>
          <td class="paramtype">PMutex_p&#160;</td>
          <td class="paramname"><em>pMutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulAdditionalMilliSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method waits on the condition variable to be signalled by another thread. Return:</p><ul>
<li>errNoError if a signal is received</li>
<li>THREADLIB_COND_TIMEDWAIT_FAILED if an error is catched (include also the case of a timeout)</li>
</ul>
<p>Important, the man page says: "It is important to note that when pthread_cond_wait() and pthread_cond_timedwait() return without error, the associated predicate may still be false. Similarly, when pthread_cond_timedwait() returns with the timeout error, the associated predicate may be true due to an unavoidable race between the expiration of the timeout and the predi- cate state change. In general, whenever a condition wait returns, the thread has to re-evaluate the predicate associated with the condition wait to determine whether it can safely proceed, should wait again, or should declare a timeout. A return from the wait does not imply that the associated predicate is either true or false."</p>
<p>It simply calls POSIX pthread_cond_timedwait primitive. Causes a thread to wait for a condition variable to be signaled or broadcast. See the wait comment. In The SUN machine a ETIME error indicates the time expired. In The HPUX machine a EAGAIN error indicates the time expired.</p>
<p>Parameters: pMutex - Mutex associated with the condition variable ulSeconds - the length of time to wait in seconds if the condition has not been signaled or broadcast ulAdditionalMilliSeconds - additional milliseconds to wait </p>

</div>
</div>
<a class="anchor" id="aa54a79a687d2ef850bf94d59f536d7a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> PCondition::wait </td>
          <td>(</td>
          <td class="paramtype">PMutex_p&#160;</td>
          <td class="paramname"><em>pMutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method waits on the condition variable to be signalled by another thread: it simply calls POSIX pthread_cond_wait primitive. Causes a thread to wait for a condition variable to be signaled or broadcast. Call this routine after you have locked the mutex specified in pMutex. The results of this routine are unpredictable if this routine is called without first locking the mutex.</p>
<p>This routine automatically releases the mutex and causes the calling thread to wait on the condition. If the wait is satisfied as a result of some thread calling signal () or broadcast (), the mutex is reacquired and the routine returns.</p>
<p>This routine might (with low probability) return when the condition variable has not been signaled or broadcast. When a spurious wakeup occurs, the mutex is reacquired before the routine returns. (To handle this type of situation, enclose this routine in a loop that checks the predicate.)</p>
<p>Parameters: pMutex - Mutex associated with the condition variable. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>PThread/src/<a class="el" href="PCondition_8h_source.html">PCondition.h</a></li>
<li>PThread/src/PCondition.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
