<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CatraLibraries: WinThread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CatraLibraries
   </div>
   <div id="projectbrief">CatraLibrariesisageneral-purposeC++framework.Itisplatformindependent(Unix,MAC,Windows,...)andprovidesclassestomanagePOSIXthreads,Sockets,SocketsConnectionManager,Tracer,Scheduler,EventsSet,Configurationfiles,HTTPCacheManager,SoftwareLoadBalancer,FTP,Tools(Buffers/Strings,DateTime,FileIO,FileReader,CPUUsage,Networks,Processes,Services,...),WebTools(HTTPGET,HTTPPOST,HTTPServer,...),Databaseaccess(Oracle,Sybase),,...</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classWinThread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">WinThread Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="WinThread_8h_source.html">WinThread.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac287c272a9e3010e5ca3e1c0b37fbe80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac287c272a9e3010e5ca3e1c0b37fbe80"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PThreadStatus</b> { <br />
&#160;&#160;<b>THREADLIB_BUILDED</b>, 
<b>THREADLIB_INITIALIZED</b>, 
<b>THREADLIB_STARTED</b>, 
<b>THREADLIB_DETACHED</b>, 
<br />
&#160;&#160;<b>THREADLIB_STARTED_AND_JOINED</b>, 
<b>THREADLIB_INITIALIZEDAGAINAFTERRUNNING</b>
<br />
 }</td></tr>
<tr class="separator:ac287c272a9e3010e5ca3e1c0b37fbe80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06383e99746432e2b5d91b72a7f432b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06383e99746432e2b5d91b72a7f432b1"></a>
typedef enum <br class="typebreak" />
WinThread::PThreadStatus&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadStatus_t</b></td></tr>
<tr class="separator:a06383e99746432e2b5d91b72a7f432b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d59899476771a1321670c4b641586b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96d59899476771a1321670c4b641586b"></a>
typedef enum <br class="typebreak" />
WinThread::PThreadStatus *&#160;</td><td class="memItemRight" valign="bottom"><b>PThreadStatus_p</b></td></tr>
<tr class="separator:a96d59899476771a1321670c4b641586b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9e1ce00971a4493835bcc27d101e6273"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWinThread.html#a9e1ce00971a4493835bcc27d101e6273">WinThread</a> ()</td></tr>
<tr class="separator:a9e1ce00971a4493835bcc27d101e6273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f808593dd3fec443974daecda84f0b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWinThread.html#ab5f808593dd3fec443974daecda84f0b">~WinThread</a> ()</td></tr>
<tr class="separator:ab5f808593dd3fec443974daecda84f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9964833002a75bff376533b9dc867e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9964833002a75bff376533b9dc867e1"></a>
<a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (const char *pPThreadName=&quot;&quot;)</td></tr>
<tr class="separator:ad9964833002a75bff376533b9dc867e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb513321ea6d63aab52bca7a8193ba5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eb513321ea6d63aab52bca7a8193ba5"></a>
virtual <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>finish</b> (void)</td></tr>
<tr class="separator:a3eb513321ea6d63aab52bca7a8193ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbcf36d9729a7521ae3c23e65ae5f81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dbcf36d9729a7521ae3c23e65ae5f81"></a>
<a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getThreadState</b> (PThreadStatus_p pstThreadState)</td></tr>
<tr class="separator:a3dbcf36d9729a7521ae3c23e65ae5f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2ac5938e458e7dfaceb8dd2ed5756e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e2ac5938e458e7dfaceb8dd2ed5756e"></a>
PThreadStatus_t&#160;</td><td class="memItemRight" valign="bottom"><b>getThreadState</b> (void)</td></tr>
<tr class="separator:a0e2ac5938e458e7dfaceb8dd2ed5756e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c58d4bb715415cf02849958715b985"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWinThread.html#ab8c58d4bb715415cf02849958715b985">start</a> (Boolean_t bToBeDetached=false)</td></tr>
<tr class="separator:ab8c58d4bb715415cf02849958715b985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f6adf456459668b589440797ca0017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWinThread.html#a30f6adf456459668b589440797ca0017">getThreadIdentifier</a> (unsigned long *pulThreadIdentifier) const </td></tr>
<tr class="separator:a30f6adf456459668b589440797ca0017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c997c12191fbcc0b176bfb7300afdc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWinThread.html#a3c997c12191fbcc0b176bfb7300afdc7">operator long</a> (void) const </td></tr>
<tr class="separator:a3c997c12191fbcc0b176bfb7300afdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5612090e2fc032f2d18c30d4e31b64e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWinThread.html#a5612090e2fc032f2d18c30d4e31b64e8">getPThreadName</a> (char *pPThreadName)</td></tr>
<tr class="separator:a5612090e2fc032f2d18c30d4e31b64e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36b35437759b31c7b4ee02d6b04438d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWinThread.html#ac36b35437759b31c7b4ee02d6b04438d">cancel</a> (void)=0</td></tr>
<tr class="separator:ac36b35437759b31c7b4ee02d6b04438d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1810146667fd5ab0095f5329d849bc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWinThread.html#ad1810146667fd5ab0095f5329d849bc2">getThreadError</a> (<a class="el" href="classError.html">Error</a> *perrThreadError)</td></tr>
<tr class="separator:ad1810146667fd5ab0095f5329d849bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86b800fee657298b80ad826adbe1c2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWinThread.html#af86b800fee657298b80ad826adbe1c2e">join</a> (Error_p perrJoinError)</td></tr>
<tr class="separator:af86b800fee657298b80ad826adbe1c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6480997818c3973ba4c8779a3fc150a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWinThread.html#a6480997818c3973ba4c8779a3fc150a6">detach</a> (void)</td></tr>
<tr class="separator:a6480997818c3973ba4c8779a3fc150a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5b3c011341b706f9c14bbda73491ad46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b3c011341b706f9c14bbda73491ad46"></a>
static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentThreadIdentifier</b> (void)</td></tr>
<tr class="separator:a5b3c011341b706f9c14bbda73491ad46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddf0d0213038a857515909fb61bf524"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWinThread.html#a9ddf0d0213038a857515909fb61bf524">getSleep</a> (unsigned long ulSeconds, unsigned long ulAdditionalMicroSeconds)</td></tr>
<tr class="separator:a9ddf0d0213038a857515909fb61bf524"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad762e7ecf7d9e57229b989f2c3cc8cb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad762e7ecf7d9e57229b989f2c3cc8cb3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>WinThread</b> (const <a class="el" href="classWinThread.html">WinThread</a> &amp;t)</td></tr>
<tr class="separator:ad762e7ecf7d9e57229b989f2c3cc8cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fc6b10679f81edd64537c451cb3128"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67fc6b10679f81edd64537c451cb3128"></a>
virtual <a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>run</b> (void)=0</td></tr>
<tr class="separator:a67fc6b10679f81edd64537c451cb3128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af108c73b6fc448df7409921fd8c7f18d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWinThread.html#af108c73b6fc448df7409921fd8c7f18d">setPThreadName</a> (const char *pPThreadName)</td></tr>
<tr class="separator:af108c73b6fc448df7409921fd8c7f18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a650c3683abac23afe4436844216c3427"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a650c3683abac23afe4436844216c3427"></a>
HANDLE&#160;</td><td class="memItemRight" valign="bottom"><b>_hEventForJoin</b></td></tr>
<tr class="separator:a650c3683abac23afe4436844216c3427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290213a2c429ffa827ecfc73b39e4171"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a290213a2c429ffa827ecfc73b39e4171"></a>
HANDLE&#160;</td><td class="memItemRight" valign="bottom"><b>_hThread</b></td></tr>
<tr class="separator:a290213a2c429ffa827ecfc73b39e4171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e15c4bbfde4788fc8264f0d8be83c24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e15c4bbfde4788fc8264f0d8be83c24"></a>
<a class="el" href="classError.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_erThreadReturn</b></td></tr>
<tr class="separator:a6e15c4bbfde4788fc8264f0d8be83c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4d55e133057d7df8caa11c1b9306cc06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d55e133057d7df8caa11c1b9306cc06"></a>
unsigned __stdcall&#160;</td><td class="memItemRight" valign="bottom"><b>runFunction</b> (void *pvWinThread)</td></tr>
<tr class="separator:a4d55e133057d7df8caa11c1b9306cc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class will have the same interface as <a class="el" href="classPosixThread.html">PosixThread</a>. Therefore, to have more information, see the <a class="el" href="classPosixThread.html">PosixThread</a> documentation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9e1ce00971a4493835bcc27d101e6273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WinThread::WinThread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="ab5f808593dd3fec443974daecda84f0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WinThread::~WinThread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac36b35437759b31c7b4ee02d6b04438d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classError.html">Error</a> WinThread::cancel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>On Windows it is not possible to cancel a thread (?). Therefore each thread have to implement this method in order to finish the thread. </p>

</div>
</div>
<a class="anchor" id="a6480997818c3973ba4c8779a3fc150a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> WinThread::detach </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks a thread object for deletion. If thread has not terminated when this method is called, this method does not cause it to terminate. Call this routine when a thread object is no longer referenced. Additionally, call this routine for every thread that is created to ensure that storage for thread objects does not accumulate. You cannot join with a thread after the thread has been detached</p>
<p>After the calling of this method, is not necessary that the user calls the finish method because when the thread terminates, will be called the method finish and the thread object will be destroyed automatically. </p>

</div>
</div>
<a class="anchor" id="a5612090e2fc032f2d18c30d4e31b64e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> WinThread::getPThreadName </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pPThreadName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this thread's class name. Parameters: pPThreadName - thread name. </p>

</div>
</div>
<a class="anchor" id="a9ddf0d0213038a857515909fb61bf524"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> WinThread::getSleep </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulAdditionalMicroSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of lSeconds plus the specified number of microseconds (1/1000000 of secs). Parameters: lSeconds - the length of time to sleep in seconds lAdditionalMicroSeconds - additional microseconds to sleep. On SUN machine only the lSeconds parameter is considered. </p>

</div>
</div>
<a class="anchor" id="ad1810146667fd5ab0095f5329d849bc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> WinThread::getThreadError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classError.html">Error</a> *&#160;</td>
          <td class="paramname"><em>perrThreadError</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this thread's error. Parameters: perrThreadError - return value of the thread error. </p>

</div>
</div>
<a class="anchor" id="a30f6adf456459668b589440797ca0017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> WinThread::getThreadIdentifier </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>pulThreadIdentifier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the thread identifier </p>

</div>
</div>
<a class="anchor" id="af86b800fee657298b80ad826adbe1c2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> WinThread::join </td>
          <td>(</td>
          <td class="paramtype">Error_p&#160;</td>
          <td class="paramname"><em>perrJoinError</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the calling thread to wait for the termination of this thread. A call to this method returns after this thread has terminated. The returned error is the error of the customized class. The perrJoinError argument contains the eventual error of the join method (eventual failure of the pthread_join API) </p>

</div>
</div>
<a class="anchor" id="a3c997c12191fbcc0b176bfb7300afdc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WinThread::operator long </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the thread identifier </p>

</div>
</div>
<a class="anchor" id="af108c73b6fc448df7409921fd8c7f18d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> WinThread::setPThreadName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pPThreadName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this thread's class name. Parameters: pPThreadName - thread name. </p>

</div>
</div>
<a class="anchor" id="ab8c58d4bb715415cf02849958715b985"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classError.html">Error</a> WinThread::start </td>
          <td>(</td>
          <td class="paramtype">Boolean_t&#160;</td>
          <td class="paramname"><em>bToBeDetached</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Causes this thread to begin execution. The result is that two threads are running concurrently: the current thread (which returns from the call to the start method) and the other thread (which executes its run method).</p>
<p>bToBeDetached: If you have to detach a thread normally you will do: start () detach () If the thread is too fast potentially when you will call detach, the thread is already finished. In this case we could have memory leak. The parameter bToBeDetached make atomic the two calls avoiding any memory leak. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>PThread/src/<a class="el" href="WinThread_8h_source.html">WinThread.h</a></li>
<li>PThread/src/WinThread.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
